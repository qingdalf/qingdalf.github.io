{"meta":{"title":"倚楼听雨","subtitle":"welcome to my blog.","description":"倚楼听风雨，淡看江湖路。","author":"qingdalf","url":"https://scaven.site","root":"/"},"pages":[{"title":"分类","date":"2021-04-20T02:37:39.000Z","updated":"2021-04-20T02:42:41.038Z","comments":false,"path":"categories/index.html","permalink":"https://scaven.site/categories/index.html","excerpt":"","text":"HomeLinuxpythonkubernetsDevOpsAboutMedocker"},{"title":"contents","date":"2021-04-21T06:34:21.000Z","updated":"2021-04-21T06:38:17.099Z","comments":false,"path":"contents/index.html","permalink":"https://scaven.site/contents/index.html","excerpt":"","text":"HomeLinuxpythonkubernetsDevOpsAboutMe"},{"title":"tags","date":"2021-04-20T02:32:02.000Z","updated":"2021-04-20T02:40:52.053Z","comments":false,"path":"tags/index.html","permalink":"https://scaven.site/tags/index.html","excerpt":"","text":"welcomeLinuxpythonkubernetsDevOpsAboutMe"},{"title":"关于","date":"2021-04-18T14:57:22.000Z","updated":"2021-04-19T02:41:56.107Z","comments":true,"path":"bak/about/index.html","permalink":"https://scaven.site/bak/about/index.html","excerpt":"","text":"贺新郎·甚矣吾衰矣 【作者】辛弃疾 【朝代】宋 邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。 甚矣吾衰矣。怅平生、交游零落，只今余几！白发空垂三千丈，一笑人间万事。问何物、能令公喜？我见青山多妩媚，料青山见我应如是。情与貌，略相似。 一尊搔首东窗里。想渊明、停云诗就，此时风味。江左沉酣求名者，岂识浊醪妙理。回首叫、云飞风起。不恨古人吾不见，恨古人、不见吾狂耳。知我者，二三子。"},{"title":"归档","date":"2021-04-18T14:54:26.000Z","updated":"2021-04-18T14:55:18.321Z","comments":false,"path":"bak/archives/index.html","permalink":"https://scaven.site/bak/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-18T14:56:25.000Z","updated":"2021-04-18T14:57:10.386Z","comments":false,"path":"bak/categories/index.html","permalink":"https://scaven.site/bak/categories/index.html","excerpt":"","text":""},{"title":"日历","date":"2021-04-18T14:55:33.000Z","updated":"2021-04-18T14:56:12.693Z","comments":false,"path":"bak/schedule/index.html","permalink":"https://scaven.site/bak/schedule/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-18T14:07:05.000Z","updated":"2021-04-20T02:27:33.658Z","comments":false,"path":"bak/tags/index.html","permalink":"https://scaven.site/bak/tags/index.html","excerpt":"","text":"welcomelinuxpythonkubernetsDevOpsAboutMe"}],"posts":[{"title":"PythonVarString","slug":"PythonVarString","date":"2021-04-21T06:33:54.000Z","updated":"2021-04-21T06:33:54.661Z","comments":true,"path":"2021-04/21-PythonVarString/","link":"","permalink":"https://scaven.site/2021-04/21-PythonVarString/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"PythonContents","slug":"PythonContents","date":"2021-04-21T06:23:40.000Z","updated":"2021-04-21T06:40:50.737Z","comments":true,"path":"2021-04/21-PythonContents/","link":"","permalink":"https://scaven.site/2021-04/21-PythonContents/","excerpt":"","text":"python入门知识： 安装python：https://scaven.site/2021-04/21-PythonInstall/ python基础知识–变量和字符串：https://scaven.site/2021-04/21-PythonVarString/","categories":[],"tags":[]},{"title":"安装python","slug":"PythonInstall","date":"2021-04-21T06:16:03.000Z","updated":"2021-04-21T06:18:10.934Z","comments":true,"path":"2021-04/21-PythonInstall/","link":"","permalink":"https://scaven.site/2021-04/21-PythonInstall/","excerpt":"","text":"第一章 起步–安装python​ python的安装可参考python官方给出的文档，官方文档从unix、windows和mac系统都给出了安装python的方法 官方python安装文档地址：https://docs.python.org/zh-cn/3.9/using/index.html ​ 当然，除了参考官方文档外，也可以参考本文安装教程，本篇python安装教程是之前在博客园写的笔记，此处直接使用博客园的笔记。 博客园笔记地址： windows系统安装python：https://www.cnblogs.com/scaven-01/p/11397965.html Linux系统安装python：https://www.cnblogs.com/scaven-01/p/11395816.html 1.在win10中安装python3.6.61.1 登录到官网下载指定python版本(1).登录到python官网：https://www.python.org/，点击Downloads (2).选择需要下载的版本，点击版本后的Download (3).选择操作系统为Windows的exe文件进行下载 (4).下载到桌面后，查看文件属性，如下图： 1.2.在win10中安装python3.6.6(1).双击python-3.6.6-amd64.exe文件，进入安装界面，选择Customize installation进行下一步安装， (2).选择需要安装的功能，根据业务需求进行选择安装，完成后点击Next (3).选择需要安装的高级功能选项，根据业务需求进行选择安装，并设定安装路径，完成后点击Install进行安装 (4).配置完成进行安装 (5).安装成功： (6).验证安装，在windows系统的cmd命令提示符中输入python -V查看python版本信息，能查看到版本信息，则证明安装没有问题（如下图），若查询不到版本信息，请重新安装： 备注：服务能正常跑起来才能证明服务没有问题，并不是安装完成没有任何报错就成功了，严谨的态度是安装完成后应该验证安装的结果。 1.3.windows系统中运行python的几种方法(1).点击电脑桌面上的windows图标，找到刚刚安装的Python3.6文件夹，点击IDLE或者Python3.6 (2).打开windows系统的cmd命令提示符，输入python进入，退出python的方法有两种–ctrl+z或者输入exit() (3).在window10的搜索框里输入IDLE，点击回车进入IDLE，如下图： 点击回车后，界面如下 2.在linux系统中安装python​ 下面在Linux系统(此处以CentOS7为例)安装python的方法，使用其中一个就行。 2.1 方法1–通过yum的方式安装​ linux系统中默认安装了python2.7，python2已经不再维护，因此我们需要学习python3，在Linux系统中python2和python3可以共存，因此我们直接通过yum的方式安装python3 Unix 系统中，为了不与同时安装的 Python 2.x 冲突，Python 3.x 解释器默认安装的执行文件名不是 python 12345678# yum -y install python3## 安装完成后检查python版本，能检查出python版本说明安装成功# python -V # 默认的python版本是2.7.5Python 2.7.5# python3 -VPython 3.6.8 2.2 方法2–源码安装python2.2.1.登录到官网下载指定python版本(1).登录到Python官网：https://www.python.org/ (2).选择指定版本的软件包进行下载： 2.2.2.在CentOS7中源码安装python3.6.6并验证安装结果(1).环境准备–安装依赖包 12#配置yum源，以便安装依赖软件包# yum clean all &amp;&amp; yum repolist 12# 安装依赖，其中readline-devel包是防止在新安装的环境中不能使用方向键的问题# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel gcc gcc-c++ (2).如果不愿意在Windows系统中下载python并上传到CentOS7系统中，可在CentOS7中使用wget命令直接下载python源码包，并进行源码编译安装python 123456##下载指定版本的python源码包# wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tar.xz # tar xvf Python-3.6.6.tar.xz # cd Python-3.6.6/ # ./configure --prefix=/usr/local/python3 # 安装到指定目录中/usr/local/python3# make &amp;&amp; make install (3).将python3和pip添加到环境变量中 1# ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3 12# 将pip也添加到环境变量# ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3 12# 查看pip的版本号# pip3 -V 2.2.3.常见安装问题​ 当我们为安装成功Python3而开心兴奋之时，我们发现我们的方向键无法使用了，如下图所示，解决方案是安装readline-devel软件包. 3. 在mac中安装python​ 在mac笔记本中安装python请参考官网教程，官网地址：https://docs.python.org/zh-cn/3/using/mac.html 4.选择一个好用的编辑器​ 工欲善其事，必先利其器。选择一个好用的python编辑器将达到事半功倍的效果，我选择的python编辑器是vscode，免费和扩展插件多是我选择的主要原因，安装教程可自行百度，此处不在赘述。 ​ 此处附上vscode官网下载和安装教程，可供参考。 vscode下载地址：https://code.visualstudio.com/ vscode官方安装教程：https://code.visualstudio.com/docs/setup/setup-overview","categories":[{"name":"python","slug":"python","permalink":"https://scaven.site/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://scaven.site/tags/python/"}]},{"title":"k8s-service","slug":"k8s-service","date":"2021-04-20T16:00:06.000Z","updated":"2021-04-20T16:29:03.189Z","comments":true,"path":"2021-04/21-k8s-service/","link":"","permalink":"https://scaven.site/2021-04/21-k8s-service/","excerpt":"","text":"第七章 Service对外暴露应用1. Service是什么Q1:如何让前端连接后端？ ​ 物理服务器/虚拟机都是通过IP地址相互访问的，IP地址是固定的，那么为啥kubernets不能通过ip访问呢 Pod的IP地址是随机分配的 Pod的IP随着Pod的启动而变化 ​ 容器的IP地址是临时的(随着容器的启动随机进行分配)，且多个pod有多个IP地址，因此我们不能通过IP地址进行连接，我们需要使用一个统一的访问入口，这个统一的访问入口就等同于一个负载均衡器，这时Service就排上了用场。 Q2：后端程序多个Pod如何同时提供服务？ ​ 通过统一的访问入口，让Service统一将请求分发(负载均衡)到后端程序提供服务，并且Service拥有动态感知Pod的能力，Pod的IP发生变化或者有新的Pod加入，Service能自动将流量分发到这些变化和新加入的Pod上 总结： ​ 前端用户(user)–连接LB的IP地址，LB将用户流量分发到后端pod，并随时感知pod的状态变化，自动更新负载策略(如，pod故障就不转发流量到故障pod上；又新加入的pod，自动将podip加入负载策略中) 2. Service存在的意义Service引入主要是解决了Pod的动态变化，提供统一的访问入口： 防止Pod失联，准备找到提供同一个服务器的Pod(服务发现) 定义一组Pod的访问策略(负载均衡) Pod与Service的关系： Service通过标签关联Pod Service使用iptables或者ipvs为一组Pod提供负载均衡能力 123456789101112131415# kubectl get pod --show-labels # 通过--show-labels查看标签NAME READY STATUS RESTARTS AGE LABELSjava-demo-56d54df448-7mhg8 1/1 Running 0 11h app=java-demo,pod-template-hash=56d54df448java-demo-56d54df448-dx767 1/1 Running 0 11h app=java-demo,pod-template-hash=56d54df448java-demo-56d54df448-flh48 1/1 Running 0 11h app=java-demo,pod-template-hash=56d54df448nginx-6799fc88d8-825ps 1/1 Running 0 34h app=nginx,pod-template-hash=6799fc88d8web-86cd4d65b9-554kq 1/1 Running 0 11h app=web,pod-template-hash=86cd4d65b9web-86cd4d65b9-65nkq 1/1 Running 0 11h app=web,pod-template-hash=86cd4d65b9web-86cd4d65b9-7zml9 1/1 Running 0 11h app=web,pod-template-hash=86cd4d65b9# kubectl get pod -l app=web # 通过-l过滤标签NAME READY STATUS RESTARTS AGEweb-86cd4d65b9-554kq 1/1 Running 0 11hweb-86cd4d65b9-65nkq 1/1 Running 0 11hweb-86cd4d65b9-7zml9 1/1 Running 0 11h 3. Service的定义与创建3.1 命令行创建123# 此处我们不做创建，只做检查# kubectl expose deployment web --port=80 --target-port=80 --dry-run=clientservice/web exposed (dry run) 3.2 yaml文件创建12# 如果不会写yaml，我们仍然可以通过--dry-run=client -o yaml将yaml文件导出# kubectl expose deployment web --port=80 --target-port=80 --dry-run=client -o yaml &gt; web_service.yaml 4.Service的三种类型4.1 ClusterIP​ 默认，分配一个稳定的IP地址，即VIP，只能在集群内部访问。用户不能直接访问，只是解决了如何在集群内部访问，即node和pod，pod和pod之间的访问。 1234567891011121314151617# cat web_service.yaml # 通过是上面的命令生成的yaml文件。默认类型为clusterIPapiVersion: v1kind: Servicemetadata: creationTimestamp: null # 删除创建时间戳 labels: # svc的标签 app: web name: web # svc的名称spec: ports: - port: 80 # Service暴露的端口 protocol: TCP targetPort: 80 # 容器使用的端口，即将容器的80端口与Service的80端口做关联 selector: # 关联后端的Pod的标签，即通过这个标签去找到对应的pod，跟资源(如pod,deploy)类型中的metadata.labels一致 app: webstatus: # 删除该字段 loadBalancer: &#123;&#125; 4.2 NodePort​ 在每个节点上启用一个端口来暴露服务，可以在集群外部访问，但也会创建一个稳定的ClusterIP，端口在30000-32767(端口可指定，默认自动分配)之间，访问地址为&lt;任意NodeIP&gt;:，这样会在每台Node上监听端口接收用户流量，在实际情况下，对用户暴露的只会有一个IP和端口，那这么多台用哪台让用户访问呢？一般的做法是加一个公网负载均衡器，让项目提供统一的访问入口 企业常见用法： 12345678910111213141516171819# cat web_service.yaml # 指定端口和类型apiVersion: v1kind: Servicemetadata: creationTimestamp: null # 删除创建时间戳 labels: app: web name: web spec: type: NodePort # 指定类型为NodePort,可在集群外访问 ports: - port: 80 protocol: TCP targetPort: 80 nodePort: 30023 # 如果想指定端口，可添加该字段，不指定端口则自动分配，范围在30000-32767 selector: app: webstatus: # 删除该字段 loadBalancer: &#123;&#125; 4.3 LoadBalancer (LB)​ 与NodePort类似，适用于公有云，在每个节点启用一个端口来暴露服务，除此之外，k8s会请求底层云平台(如阿里云，aws等)上的负载均衡器，自动将每个Node(&lt;任意NodeIP&gt;:)作为后端添加进去，可查阅云厂商相关文档 5. Service代理模式 iptables(默认规则) 灵活，功能强大 规则遍历匹配和更新，呈线性时延，不适用于大集群(建议service小于100，pod副本数跟service比例在1:3-5可使用iptables) 查看iptables规则：iptables-save |grep 查看规则的方法： 1234567891011121314151617# 1. 通过kube-proxy的配置文件# 2. 通过kube-proxy的日志，我们是通过容器启动的，因此就通过该方法查看# kubectl get pods -n kube-system | grep proxykube-proxy-bzhts 1/1 Running 1 11dkube-proxy-fd5q2 1/1 Running 1 11dkube-proxy-p6hmt 1/1 Running 1 11d# kubectl logs kube-proxy-p6hmt -n kube-system # 查看任意一个proxy Pod的日志I0420 06:35:30.109968 1 node.go:172] Successfully retrieved node IP: 10.138.3.61I0420 06:35:30.110014 1 server_others.go:142] kube-proxy node IP is an IPv4 address (10.138.3.61), assume IPv4 operationW0420 06:35:30.134968 1 server_others.go:578] Unknown proxy mode &quot;&quot;, assuming iptables proxy# 此处的&quot;proxy mode &quot;&quot;, assuming iptables proxy&quot;表示，如果模式为空，则使用iptables规则I0420 06:35:30.135048 1 server_others.go:185] Using iptables Proxier.I0420 06:35:30.135559 1 server.go:650] Version: v1.20.0I0420 06:35:30.135919 1 conntrack.go:100] Set sysctl &#x27;net/netfilter/nf_conntrack_max&#x27; to 131072···· ipvs 工作在内核，有更好的性能，适合于大集群，建议使用 调度算法丰富：rr，wrr，lc，wlc，ip hash··· 查看ipvs规则：ipvsadm -L -n 5.1 iptables12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 获取容器IP，iptables规则一定会将流量转发到容器IP# kubectl get pods -o wide | grep nginx # 记住容器IP，iptables规则一定会将流量转发到容器IPnginx-6799fc88d8-825ps 1/1 Running 1 10d 10.244.154.198 k8s-node-01 &lt;none&gt; &lt;none&gt;# 获取svc IP，svc IP一定会去关联后端的容器IP，才能让用户访问到应用信息# kubectl get svc -o wide | grep nginx nginx NodePort 10.103.247.121 &lt;none&gt; 80:32561/TCP 11d app=nginx# 端点信息# kubectl get ep | grep nginxnginx 10.244.154.198:80 11d# ss -lntp | grep proxyLISTEN 0 128 127.0.0.1:10249 *:* users:((&quot;kube-proxy&quot;,pid=2994,fd=18))LISTEN 0 128 *:32561 *:* users:((&quot;kube-proxy&quot;,pid=2994,fd=13))LISTEN 0 128 *:30001 *:* users:((&quot;kube-proxy&quot;,pid=2994,fd=10))LISTEN 0 128 [::]:10256 [::]:* users:((&quot;kube-proxy&quot;,pid=2994,fd=19))# iptables规则# iptables-save | grep nginx # 此处的nginx是service的名称## 1.访问nodePort，端口是32561时，将流量转发到KUBE-SVC-2CMXP7HKUVJN7L6M链-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp --dport 32561 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp --dport 32561 -j KUBE-SVC-2CMXP7HKUVJN7L6M ## 3.将来自KUBE-SEP-FIC36SCPQQINK7HE链的规则，通过DNAT(目标地址转换)转发到10.244.154.198:80(容器IP和端口)容器中## 如果有多个容器，会添加多条相同的规则和负载规则策略，只是--to-destination的IP地址不同-A KUBE-SEP-FIC36SCPQQINK7HE -s 10.244.154.198/32 -m comment --comment &quot;default/nginx&quot; -j KUBE-MARK-MASQ-A KUBE-SEP-FIC36SCPQQINK7HE -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp -j DNAT --to-destination 10.244.154.198:80-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.103.247.121/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ## 1.访问clusterIP的转发，目标地址是10.103.247.121/32(svc地址)，目标端口是80 ，协议是tcp的流量，转发到KUBE-SVC-2CMXP7HKUVJN7L6M链中-A KUBE-SERVICES -d 10.103.247.121/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-2CMXP7HKUVJN7L6M## 2.从nodeport和clusterIP两种类型来的流量，都来匹配这条规则## 含义是：把所有从KUBE-SVC-2CMXP7HKUVJN7L6M链来的规则都交给KUBE-SEP-FIC36SCPQQINK7HE链去处理-A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment &quot;default/nginx&quot; -j KUBE-SEP-FIC36SCPQQINK7HE# 我们将集群nginx容器扩容到3个pod# kubectl scale deployment nginx --replicas=3 deployment.apps/nginx scaled# 等待创建完所有pod# kubectl get ep | grep nginx # 这里是所有nginx容器的IP地址和端口nginx 10.244.154.198:80,10.244.44.209:80,10.244.44.210:80 11d# 我们再次来查看iptables规则# iptables-save | grep nginx## 1. 从nodeport来的流量-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp --dport 32561 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp --dport 32561 -j KUBE-SVC-2CMXP7HKUVJN7L6M# 3.上文中存在的转发规则-A KUBE-SEP-FIC36SCPQQINK7HE -s 10.244.154.198/32 -m comment --comment &quot;default/nginx&quot; -j KUBE-MARK-MASQ-A KUBE-SEP-FIC36SCPQQINK7HE -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp -j DNAT --to-destination 10.244.154.198:80## 3.多出来的第一个规则，转发到第二个pod-A KUBE-SEP-FU7B2O7TL4BNEJXI -s 10.244.44.210/32 -m comment --comment &quot;default/nginx&quot; -j KUBE-MARK-MASQ-A KUBE-SEP-FU7B2O7TL4BNEJXI -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp -j DNAT --to-destination 10.244.44.210:80# 3.多出来的第二个规则，转发到第三个pod-A KUBE-SEP-HJU6P624NH7ZFLEO -s 10.244.44.209/32 -m comment --comment &quot;default/nginx&quot; -j KUBE-MARK-MASQ-A KUBE-SEP-HJU6P624NH7ZFLEO -p tcp -m comment --comment &quot;default/nginx&quot; -m tcp -j DNAT --to-destination 10.244.44.209:80# 1.从clusterIP来的流量-A KUBE-SERVICES ! -s 10.244.0.0/16 -d 10.103.247.121/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ-A KUBE-SERVICES -d 10.103.247.121/32 -p tcp -m comment --comment &quot;default/nginx cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-2CMXP7HKUVJN7L6M## 下面的三条策略，从上倒下匹配--Iptables使用概率来保障pod负载均衡分配# 多出来的转发策略---A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment &quot;default/nginx&quot; -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-FIC36SCPQQINK7HE# 多出来的转发策略---A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment &quot;default/nginx&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-HJU6P624NH7ZFLEO# 默认的匹配(转发)规则---A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment &quot;default/nginx&quot; -j KUBE-SEP-FU7B2O7TL4BNEJXI 根据上面的iptables规则可以知道，只是入口不一样(nodeport或clusterip)，入口后的规则都是一样的，因此一般情况下数据包准发流程如下： 通过访问clusterIP来访问pod(集群内)，即user–&gt;clusterIP–&gt;PodIP(多个IP) 通过访问nodeIP来访问pod(集群外)，即user–&gt;NodePort(多个集群IP)–&gt;PodIP(多个IP) 5.2 ipvs​ 通过上文，我们已经知道了默认模式是iptables，如果我们想使用ipvs规则，需要进行模式的修改。 修改方式： 二进制部署，通过配置文件kube-proxy-config.yml修改，修改imode，然后重启kube-proxy服务 容器部署，通过kubeadm的方式修改，此处采用该方式 12# kubectl edit configmap kube-proxy -n kube-systemconfigmap/kube-proxy edited 如下图： 重置容器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# k8s中没有容器Pod的概念，因此此处直接删除pod，让其重建pod# kubectl get pods -n kube-system -o wide | grep proxy kube-proxy-bzhts 1/1 Running 1 11d 10.138.3.62 k8s-node-01 &lt;none&gt; &lt;none&gt;kube-proxy-fd5q2 1/1 Running 1 11d 10.138.3.63 k8s-node-02 &lt;none&gt; &lt;none&gt;kube-proxy-p6hmt 1/1 Running 1 11d 10.138.3.61 k8s-master &lt;none&gt; &lt;none&gt;# 先删除其中一个(k8s-node-01)，然后验证合法后，再进行其他两台的操作# kubectl delete pod kube-proxy-bzhts -n kube-systempod &quot;kube-proxy-bzhts&quot; deleted# kubectl get pods -n kube-system -o wide | grep proxy kube-proxy-fd5q2 1/1 Running 1 11d 10.138.3.63 k8s-node-02 &lt;none&gt; &lt;none&gt;kube-proxy-lndks 1/1 Running 0 8s 10.138.3.62 k8s-node-01 &lt;none&gt; &lt;none&gt;kube-proxy-p6hmt 1/1 Running 1 11d 10.138.3.61 k8s-master &lt;none&gt; &lt;none&gt;# kubectl get svc -o wide | grep nginxnginx NodePort 10.103.247.121 &lt;none&gt; 80:32561/TCP 11d app=nginx# 验证(在k8s-node-01验证)：安装ipvs，并查看规则# yum -y install ipvsadm# ipvsadm -LnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 10.96.0.1:443 rr # 默认规则就是rr -&gt; 10.138.3.61:6443 Masq 1 0 0 TCP 10.96.0.10:53 rr -&gt; 10.244.235.196:53 Masq 1 0 0 -&gt; 10.244.235.197:53 Masq 1 0 0 TCP 10.96.0.10:9153 rr -&gt; 10.244.235.196:9153 Masq 1 0 0 -&gt; 10.244.235.197:9153 Masq 1 0 0 TCP 10.99.141.98:8000 rr -&gt; 10.244.44.208:8000 Masq 1 0 0 TCP 10.100.90.183:443 rr -&gt; 10.244.154.197:8443 Masq 1 0 0 TCP 10.103.247.121:80 rr # svc的IP地址：10.103.247.121，通过svc地址(clusterIP)访问的流量转发 -&gt; 10.244.44.209:80 Masq 1 0 0 -&gt; 10.244.44.210:80 Masq 1 0 0 -&gt; 10.244.154.198:80 Masq 1 0 0 TCP 10.138.3.62:30001 rr -&gt; 10.244.154.197:8443 Masq 1 0 0 TCP 10.138.3.62:32561 rr # 宿主机IP地址：10.138.3.62，通过nodeport访问的流量转发 -&gt; 10.244.44.209:80 Masq 1 0 0 -&gt; 10.244.44.210:80 Masq 1 0 0 -&gt; 10.244.154.198:80 Masq 1 0 0 TCP 10.244.154.192:30001 rr -&gt; 10.244.154.197:8443 Masq 1 0 0 TCP 10.244.154.192:32561 rr # 通过网卡tunl0@NONE访问，网卡信息看下文 -&gt; 10.244.44.209:80 Masq 1 0 0 -&gt; 10.244.44.210:80 Masq 1 0 0 -&gt; 10.244.154.198:80 Masq 1 0 0 TCP 127.0.0.1:30001 rr -&gt; 10.244.154.197:8443 Masq 1 0 0 TCP 127.0.0.1:32561 rr # 通过lo:32561访问nginx容器(NodePort) -&gt; 10.244.44.209:80 Masq 1 0 0 -&gt; 10.244.44.210:80 Masq 1 0 0 -&gt; 10.244.154.198:80 Masq 1 0 0 TCP 172.17.0.1:30001 rr -&gt; 10.244.154.197:8443 Masq 1 0 0 TCP 172.17.0.1:32561 rr # 172.17.0.1 docker0的IP地址 -&gt; 10.244.44.209:80 Masq 1 0 0 -&gt; 10.244.44.210:80 Masq 1 0 0 -&gt; 10.244.154.198:80 Masq 1 0 0 UDP 10.96.0.10:53 rr -&gt; 10.244.235.196:53 Masq 1 0 0 -&gt; 10.244.235.197:53 Masq 1 0 0 # ip a # 网卡信息发生了变化1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:f8:4c:a3 brd ff:ff:ff:ff:ff:ff inet 10.138.3.62/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::edf4:6c5f:a090:110/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:b9:85:b5:e8 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever4: tunl0@NONE: &lt;NOARP,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UNKNOWN group default qlen 1000 link/ipip 0.0.0.0 brd 0.0.0.0 # 不知道干啥的？？？？ inet 10.244.154.192/32 scope global tunl0 valid_lft forever preferred_lft forever5: cali76d2c4cb462@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UP group default link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::ecee:eeff:feee:eeee/64 scope link valid_lft forever preferred_lft forever6: cali2941b9a4026@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1480 qdisc noqueue state UP group default link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::ecee:eeff:feee:eeee/64 scope link valid_lft forever preferred_lft forever7: dummy0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 02:a3:b5:68:00:72 brd ff:ff:ff:ff:ff:ff8: kube-ipvs0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default # 新出现的网卡 link/ether ae:50:d0:2b:72:2b brd ff:ff:ff:ff:ff:ff inet 10.96.0.1/32 scope global kube-ipvs0 valid_lft forever preferred_lft forever inet 10.103.247.121/32 scope global kube-ipvs0 valid_lft forever preferred_lft forever inet 10.96.0.10/32 scope global kube-ipvs0 valid_lft forever preferred_lft forever inet 10.99.141.98/32 scope global kube-ipvs0 valid_lft forever preferred_lft forever inet 10.100.90.183/32 scope global kube-ipvs0 valid_lft forever preferred_lft forever # 删除其他两个proxy pod# kubectl get pods -o wide -n kube-system |grep proxy\\kube-proxy-fd5q2 1/1 Running 1 11d 10.138.3.63 k8s-node-02 &lt;none&gt; &lt;none&gt;kube-proxy-lndks 1/1 Running 0 39m 10.138.3.62 k8s-node-01 &lt;none&gt; &lt;none&gt;kube-proxy-p6hmt 1/1 Running 1 11d 10.138.3.61 k8s-master &lt;none&gt; &lt;none&gt; # kubectl delete pod kube-proxy-fd5q2 -n kube-systempod &quot;kube-proxy-fd5q2&quot; deleted# kubectl delete pod kube-proxy-p6hmt -n kube-systempod &quot;kube-proxy-p6hmt&quot; deleted# 完成如下：# kubectl get pods -o wide -n kube-system |grep proxykube-proxy-7xhzn 1/1 Running 0 10s 10.138.3.61 k8s-master &lt;none&gt; &lt;none&gt;kube-proxy-hr7ht 1/1 Running 0 91s 10.138.3.63 k8s-node-02 &lt;none&gt; &lt;none&gt;kube-proxy-lndks 1/1 Running 0 41m 10.138.3.62 k8s-node-01 &lt;none&gt; &lt;none&gt; 5.3 工作模式 6. Service DNS名称​ CoreDNS是一个DNS服务器，k8s默认采用，以Pod部署在集群中，CoreDNS服务监视K8S API，为每个Servicd创建DNS记录用于域名解析。 ​ ClusterIP A记录格式：..svc.cluster.local，如果查询不到要么是svc不存在，要么没有指定命名空间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# kubectl get svc| grep nginx nginx NodePort 10.103.247.121 &lt;none&gt; 80:32561/TCP 11d# kubectl get svc -o wide -n kube-system # 名叫kube-dns的svc，这个就是dns的IPNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORkube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP,9153/TCP 11d k8s-app=kube-dns# kubectl run -it --image=busybox:1.28.4 -- sh/ # nslookup nginx # 查看nginx的解析信息Server: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName: nginxAddress 1: 10.103.247.121 nginx.default.svc.cluster.local/ # cat /etc/resolv.conf search default.svc.cluster.local svc.cluster.local cluster.localnameserver 10.96.0.10options ndots:5## 在其他node上删除nginx这个svc,再次查询nginx的解析信息# kubectl delete svc nginxservice &quot;nginx&quot; deleted# 在次查询Nginx的解析信息/ # nslookup nginxServer: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localnslookup: can&#x27;t resolve &#x27;nginx&#x27; # 查询失败## 在其他节点上，新建nginx的svc后，在查看解析信息# kubectl expose deployment nginx --target-port=80 --port=80 --type=NodePortservice/nginx exposed# kubectl get svc |grep nginxnginx NodePort 10.99.5.83 &lt;none&gt; 80:31031/TCP 20s # nginx的IP地址已经发生了变化# 再一次解析/ # nslookup nginxServer: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName: nginxAddress 1: 10.99.5.83 nginx.default.svc.cluster.local # 解析成功","categories":[{"name":"docker","slug":"docker","permalink":"https://scaven.site/categories/docker/"}],"tags":[{"name":"kubernets","slug":"kubernets","permalink":"https://scaven.site/tags/kubernets/"}]},{"title":"aboutme","slug":"aboutme","date":"2021-04-20T04:14:50.000Z","updated":"2021-04-20T04:16:26.643Z","comments":true,"path":"2021-04/20-aboutme/","link":"","permalink":"https://scaven.site/2021-04/20-aboutme/","excerpt":"","text":"贺新郎·甚矣吾衰矣 【作者】辛弃疾 【朝代】宋 邑中园亭，仆皆为赋此词。一日，独坐停云，水声山色，竞来相娱。意溪山欲援例者，遂作数语，庶几仿佛渊明思亲友之意云。 甚矣吾衰矣。怅平生、交游零落，只今余几！白发空垂三千丈，一笑人间万事。问何物、能令公喜？我见青山多妩媚，料青山见我应如是。情与貌，略相似。 一尊搔首东窗里。想渊明、停云诗就，此时风味。江左沉酣求名者，岂识浊醪妙理。回首叫、云飞风起。不恨古人吾不见，恨古人、不见吾狂耳。知我者，二三子。","categories":[],"tags":[{"name":"AboutMe","slug":"AboutMe","permalink":"https://scaven.site/tags/AboutMe/"}]},{"title":"docker","slug":"docker","date":"2021-04-20T04:02:58.000Z","updated":"2021-04-20T16:26:49.884Z","comments":true,"path":"2021-04/20-docker/","link":"","permalink":"https://scaven.site/2021-04/20-docker/","excerpt":"","text":"docker基础知识 开篇1.1什么是容器？​ 容器技术是一种虚拟化的方案。容器虚拟化也就是操作系统级别的虚拟化，只能运行相同或相似内核的操作系统。Docker使用的容器技术依赖于Linux内核的Namespaces和Cgroups，这两个技术就是为了让操作系统资源被区隔成独立区间。 ​ Docker能够将开发的应用程序自动部署到容器。 Docker依赖的Linux内核特性： Namespaces 命名空间 Controller groups（cgroups）控制组 1.1.1 NameSpace​ 为确保提供的是轻量级虚拟化服务，Docker使用了NameSpace。命名空间提供了系统资源的隔离，资源包括进程、网络、文件系统等。 ​ 在同一个Namespace下的进程可以感知彼此的变化，而对其他的Namespace一无所知。让容器置身于独立的系统环境中。 Namespace的种类 ： PID（Process ID） 进程隔离 NET（Network） 管理网络接口 IPC（InterProcess Communication） 管理跨进程通信的访问 MNT（Mount） 管理挂载点 UTS（Unix Timesharing System） 隔离内核和版本标识 123456789[root@docker20 ~]# ll /proc/$$/ns # $$表示当前进程的id，即1，systemd进程total 0lrwxrwxrwx 1 root root 0 Mar 31 22:48 ipc -&gt; ipc:[4026531839]lrwxrwxrwx 1 root root 0 Mar 31 22:48 mnt -&gt; mnt:[4026531840]lrwxrwxrwx 1 root root 0 Mar 31 22:48 net -&gt; net:[4026531956]lrwxrwxrwx 1 root root 0 Mar 31 22:48 pid -&gt; pid:[4026531836]lrwxrwxrwx 1 root root 0 Mar 31 22:48 user -&gt; user:[4026531837]lrwxrwxrwx 1 root root 0 Mar 31 22:48 uts -&gt; uts:[4026531838] 1.1.2 Controller groups​ cgroups是一种Linux提供用于限制、控制、管理资源的机制，所有的任务就是运行再系统中的一个进程，而Cgroups以某种标准将一组进程为目标进行资源分配和控制，例如cpu、内存、带宽等，并且可以动态配置。 cgroups的主要功能： 资源限制(Resource limitation)：可以为进程组设定资源使用上限。 优先级设定(Prioritization)：哪些进程组使用更多的资源，可以为进程组分配特定的CPU、磁盘IO吞吐量等。 资源计量(Accounting)：记录进程组使用资源的数量–统计。 进程组控制(Control)：能够将进程组挂起和恢复。 12345678910111213141516171819# ll /sys/fs/cgroup/ # cgroup执行的资源限制total 0drwxr-xr-x 4 root root 0 Apr 1 10:59 blkio # 对块设备的io进行限制lrwxrwxrwx 1 root root 11 Apr 1 10:59 cpu -&gt; cpu,cpuacct # 限制cpu时间片的分配，与cpuacct挂载同一目录lrwxrwxrwx 1 root root 11 Apr 1 10:59 cpuacct -&gt; cpu,cpuacct # 生产cgroup中的任务占用cou资源的报告，与cpu挂载同一目录drwxr-xr-x 4 root root 0 Apr 1 10:59 cpu,cpuacct drwxr-xr-x 2 root root 0 Apr 1 10:59 cpuset # 给cgroup的任务分配独立的cpu和内存节点drwxr-xr-x 4 root root 0 Apr 1 10:59 devices # 允许或者拒绝cgroup中的任务访问设备drwxr-xr-x 2 root root 0 Apr 1 10:59 freezer # 暂停/恢复cgroup中的任务drwxr-xr-x 2 root root 0 Apr 1 10:59 hugetlb # 限制使用的内存页数量drwxr-xr-x 4 root root 0 Apr 1 10:59 memory # 对cgroup中人物的额可用内存进行限制，并自动生产资源占用报告lrwxrwxrwx 1 root root 16 Apr 1 10:59 net_cls -&gt; net_cls,net_prio # 使用等级识别符(classid)标记网络数据包，这让Linux流量控制程序(tc)可以识别来自特定从cgroup任务的数据包，并进行网络限制drwxr-xr-x 2 root root 0 Apr 1 10:59 net_cls,net_prio lrwxrwxrwx 1 root root 16 Apr 1 10:59 net_prio -&gt; net_cls,net_prio # 允许基于cgroup设置网络流量的优先级drwxr-xr-x 2 root root 0 Apr 1 10:59 perf_event # 运行使用perf工具来监控cgroupdrwxr-xr-x 4 root root 0 Apr 1 10:59 pids # 限制任务的数量drwxr-xr-x 4 root root 0 Apr 1 10:59 systemd 容器实际资源限制位置：/sys/fs/cgroup/&lt;资源名&gt;/docker/&lt;容器id&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdc6d2297d670 nginx &quot;/docker-entrypoint.…&quot; 15 hours ago Up About a minute 80/tcp vibrant_hawking60ffca766bde f1cb7c7d58b7 &quot;bash&quot; 6 weeks ago Up About a minute c1# 为每个容器都创建了相应的限制目录，直接修改容器目录中的资源限制类型就能达到限制容器使用资源的目标# cpu目录下的资源限制文件，跟/sys/fs/cgroup/cpu/下的内容大同小异# ls /sys/fs/cgroup/cpu/docker/ # 下面的dc6d2297d670和60ffca766bde就是容器资源，启动容器后才会出现60ffca766bdea3ba772bc8fff9e15a5b569d213d06980f1cb56b0d50a66315cf cpuacct.usage_percpu cpu.statcgroup.clone_children cpu.cfs_period_us dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86bcgroup.event_control cpu.cfs_quota_us notify_on_releasecgroup.procs cpu.rt_period_us taskscpuacct.stat cpu.rt_runtime_uscpuacct.usage cpu.shares# ls /sys/fs/cgroup/cpu/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/cgroup.clone_children cgroup.procs cpuacct.usage cpu.cfs_period_us cpu.rt_period_us cpu.shares notify_on_releasecgroup.event_control cpuacct.stat cpuacct.usage_percpu cpu.cfs_quota_us cpu.rt_runtime_us cpu.stat tasks# cat /sys/fs/cgroup/cpu/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/tasks 19652 # nginx的父进程master进程19700 # nginx的子进程worker进程# ps -ef | grep [1]9652root 19652 19623 0 13:46 ? 00:00:00 nginx: master process nginx -g daemon off;101 19700 19652 0 13:46 ? 00:00:00 nginx: worker process# ps -ef | grep [1]9700101 19700 19652 0 13:46 ? 00:00:00 nginx: worker process# memory下的资源限制目录，跟/sys/fs/cgroup/memory/下的内容大同小异# ls /sys/fs/cgroup/memory/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/cgroup.clone_children memory.kmem.max_usage_in_bytes memory.limit_in_bytes memory.numa_stat memory.use_hierarchycgroup.event_control memory.kmem.slabinfo memory.max_usage_in_bytes memory.oom_control notify_on_releasecgroup.procs memory.kmem.tcp.failcnt memory.memsw.failcnt memory.pressure_level tasksmemory.failcnt memory.kmem.tcp.limit_in_bytes memory.memsw.limit_in_bytes memory.soft_limit_in_bytesmemory.force_empty memory.kmem.tcp.max_usage_in_bytes memory.memsw.max_usage_in_bytes memory.statmemory.kmem.failcnt memory.kmem.tcp.usage_in_bytes memory.memsw.usage_in_bytes memory.swappinessmemory.kmem.limit_in_bytes memory.kmem.usage_in_bytes memory.move_charge_at_immigrate memory.usage_in_bytes# cat /sys/fs/cgroup/memory/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/tasks 1965219700 # ps -ef | grep [1]9700101 19700 19652 0 13:46 ? 00:00:00 nginx: worker process# ps -ef | grep [1]9652root 19652 19623 0 13:46 ? 00:00:00 nginx: master process nginx -g daemon off;101 19700 19652 0 13:46 ? 00:00:00 nginx: worker process# cat /sys/fs/cgroup/memory/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/memory.limit_in_bytes 1073741824 # 显示现在分配的内存是1073741824 / 1024 / 1024 /1024 = 1g # docker stats dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b# 查看该容器的资源限制情况，显示内存限制是1GCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSdc6d2297d670 vibrant_hawking 0.00% 2.531MiB / 1GiB 0.25% 1.01kB / 0B 22.3MB / 0B 2# echo &quot;200M&quot; &gt; /sys/fs/cgroup/memory/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/memory.limit_in_bytes # 需要注意的是，修改的内存值大于限制值时将修改失败，机可以改小，不能改大# cat /sys/fs/cgroup/memory/docker/dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b/memory.limit_in_bytes 209715200 # 209715200 / 1024 / 1024 = 200M# docker stats dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b# 内存值已经变成了200mCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSdc6d2297d670 vibrant_hawking 0.00% 2.531MiB / 200MiB 1.27% 1.01kB / 0B 22.3MB / 0B 2# docker update --help # docker资源限制主要是下面的几个类型Usage: docker update [OPTIONS] CONTAINER [CONTAINER...]Update configuration of one or more containersOptions: --blkio-weight uint16 Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) --cpu-period int Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota --cpu-rt-period int Limit the CPU real-time period in microseconds --cpu-rt-runtime int Limit the CPU real-time runtime in microseconds -c, --cpu-shares int CPU shares (relative weight) --cpus decimal Number of CPUs --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) --kernel-memory bytes Kernel memory limit -m, --memory bytes Memory limit --memory-reservation bytes Memory soft limit --memory-swap bytes Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap --pids-limit int Tune container pids limit (set -1 for unlimited) --restart string Restart policy to apply when a container exits 1.2 虚拟化技术 ​ 虚拟化技术就是一种计算机资源管理技术，将内存，网络，CPU等资源进行抽象，让硬件透明，目的是让用户合理地使用操作系统资源。 容器与虚拟化 ​ 容器是应用程序层的抽象，将代码和依赖项打包在一起。多个容器可以在同一台计算机上运行，并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。 ​ 虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。系统管理程序允许多个VM在单台计算机上运行。每个VM都包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。VM也可能启动缓慢 ​ 虚拟机和容器都有优势和劣势，如何选择取决于具体的需求，但有些规则可以参考。 VM非常适合当应用运行时需要所有OS资源和功能的场景，如果需要运行多个这样的应该，可以使用VMs 容器适合在更少的server上运行更多的应用。 服务器好比运输码头：拥有场地和各种设备（服务器硬件资源） 服务器虚拟化好比作码头上的仓库：拥有独立的空间堆放各种货物或集装箱 (仓库之间完全独立，独立的应用系统和操作系统） Docker比作集装箱：各种货物的打包 (将各种应用程序和他们所依赖的运行环境打包成标准的容器,容器之间隔离) ​ Docker有着小巧、迁移部署快速、运行高效等特点，但隔离性比服务器虚拟化差：不同的集装箱属于不同的运单（Docker上运行不同的应用实例），相互独立（隔离）。但由同一个库管人员管理（主机操作系统内核），因此通过库管人员可以看到所有集装箱的相关信息（因为共享操作系统内核，因此相关信息会共享）。 ​ 服务器虚拟化就好比在码头上（物理主机及虚拟化层），建立了多个独立的“小码头”—仓库（虚拟机）。其拥有完全独立（隔离）的空间，属于不同的客户（虚拟机所有者）。每个仓库有各自的库管人员（当前虚拟机的操作系统内核），无法管理其它仓库。不存在信息共享的情况 ​ 因此，我们需要根据不同的应用场景和需求采用不同的方式使用Docker技术或使用服务器虚拟化技术。例如一个典型的Docker应用场景是当主机上的Docker实例属于单一用户的情况下，在保证安全的同时可以充分发挥Docker的技术优势。对于隔离要求较高的环境如混合用户环境，就可以使用服务器虚拟化技术。正则科技提供了丰富的Docker应用实例，满足您的各种应用需求，并且支持在已经安装了自在（Isvara）服务器虚拟化软件的主机上同时使用服务器虚拟化技术和Docker技术提供不同技术场景。 一．Docker简介1.1 docker介绍​ docker是PaaS提供商dotCloud开源的一个基于LXC的高级容器引擎，源代码托管在Github上，基于Go 语言并遵从 Apache2.0 协议开源，docker是容器的一个管理工具，并不是容器。 ​ docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制（沙箱就是一个限制应用程序对系统资源的访问的运行环境），相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 ​ docker从17.03版本之后分为CE（Community Edition: 社区版）和EE（Enterprise Edition: 企业版），我们用社区版就可以了。 ​ Docker自2013年以来非常火热，无论是从github上的代码活跃度，还是Redhat在RHEL6.5中集成对Docker的支持, 就连Google的Compute Engine也支持docker在其之上运行。 环境管理复杂 - 从各种OS到各种中间件到各种app, 一款产品能够成功作为开发者需要关心的东西太多，且难于管理，这个问题几乎在所有现代IT相关行业都需要面对。 云计算时代的到来 - AWS的成功, 引导开发者将应用转移到 cloud 上, 解决了硬件管理的问题，然而中间件相关的问题依然存在 (所以openstack HEAT和 AWS cloudformation 都着力解决这个问题)。开发者思路变化提供了可能性。 虚拟化手段的变化 - cloud 时代采用标配硬件来降低成本，采用虚拟化手段来满足用户按需使用的需求以及保证可用性和隔离性。然而无论是KVM还是Xen在 docker 看来,都在浪费资源，因为用户需要的是高效运行环境而非OS, GuestOS既浪费资源又难于管理, 更加轻量级的LXC更加灵活和快速 LXC的移动性 - LXC在 linux 2.6 的 kernel 里就已经存在了，但是其设计之初并非为云计算考虑的，缺少标准化的描述手段和容器的可迁移性，决定其构建出的环境难于迁移和标准化管理(相对于KVM之类image和snapshot的概念)。docker 就在这个问题上做出实质性的革新。这是docker最独特的地方。 ​ 面对上述几个问题，docker设想是交付运行环境如同海运，OS如同一个货轮，每一个在OS基础上的软件都如同一个集装箱，用户可以通过标准化手段自由组装运行环境，同时集装箱的内容可以由用户自定义，也可以由专业人员制造。这样，交付一个软件，就是一系列标准化组件的集合的交付，如同乐高积木，用户只需要选择合适的积木组合，并且在最顶端署上自己的名字(最后一个标准化组件是用户的app)。这也就是基于docker的PaaS产品的原型。 1.2 Docker 架构​ Docker使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker容器通过Docker镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类，可以理解为程序和进程的关系，镜像是静态的，容器是动态的有生命周期的。 docker 面向对象 容器 对象 镜像 类 架构图一 ​ Docker采用C/S架构，Docker daemon 作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。 客户端和服务端既可以运行在一个机器上，也可通过 socket 或者RESTful API 来进行通信。 ​ Docker daemon一般在宿主主机后台运行，等待接收来自客户端的消息。 Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟Docker daemon交互。 架构图二 ​ 不难发现，docker由内到外是docker daemon（守护进程），docker client（客户端），container（容器），image（镜像），network（网络），data volumes（数据卷） Docker的基本组成有： Docker Client：客户端，Docker客户端通过命令行或者其他工具使用Docker SDK与Docker的守护进程通信 Docker Daemon：守护进程， Docker Image：镜像，Docker镜像是用于创建Docker容器的模板。 Docker Container：容器，容器是独立运行的一个或一组应用 Docker Registry：仓库，Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。 Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。用户可创建自己的私有仓库。默认使用https协议进行访问。 拥有两层功能，提供镜像存储的仓库，提供用户获取镜像时的认证 Docker Host：docker运行的主机，一个物理或者虚拟的机器用于执行Docker守护进程和容器。 Containerd：是一个简单的守护进程，向上给Docker Daemon提供接口，向下通过containerd-shim结合runC管理容器 runC：一个命令行工具，它根据OCI标准来创建和运行容器。 1# ps ajxf # 执行结果如下，他们之间的pid存在相互关联的关系 1.3 docker的优缺点1.3.1 docker优点​ Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。 快速，一致地交付您的应用程序 ​ Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。 ​ 容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案： ​ 您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。 ​ 他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。 ​ 当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。 ​ 测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。 响应式部署和扩展 ​ Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。 ​ Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。 在同一硬件上运行更多工作负载 ​ Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。 1.3.2 docker局限Docker并不是全能的，设计之初也不是KVM之类虚拟化手段的替代品，简单总结几点： Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用 LXC是基于cgroup等linux kernel功能的，因此container的guest系统只能是linux base的 隔离性相比KVM之类的虚拟化方案还是有些欠缺，所有container公用一部分的运行库 网络管理相对简单，主要是基于namespace隔离 cgroup的cpu和cpuset提供的cpu功能相比KVM的等虚拟化方案相比难以度量(所以dotcloud主要是按内存收费) Docker对disk的管理比较有限 container随着用户进程的停止而销毁，container中的log等用户数据不便收集 ​ 针对1-2，有windows base应用的需求的基本可以pass了; 3-5主要是看用户的需求，到底是需要一个container还是一个VM, 同时也决定了docker作为 IaaS 不太可行。 ​ 针对6,7虽然是docker本身不支持的功能，但是可以通过其他手段解决(disk quota, mount –bind)。总之，选用container还是vm, 就是在隔离性和资源复用性上做权衡。 ​ Docker在本质上是一个附加系统。使用文件系统的不同层构建一个应用是有可能的。每个组件被添加到之前已经创建的组件之上，可以比作为一个文件系统更明智。分层架构带来另一方面的效率提升，当你重建存在变化的Docker镜像时，不需要重建整个Docker镜像，只需要重建变化的部分。 ​ 可能更为重要的是，Docker旨在用于弹性计算。每个Docker实例的运营生命周期有限，实例数量根据需求增减。在一个管理适度的系统中，这些实例生而平等，不再需要时便各自消亡了。 ​ 针对Docker环境存在的不足，意味着在开始部署Docker前需要考虑如下几个问题。首先，Docker实例是无状态的。这意味着它们不应该承载任何交易数据，所有数据应该保存在数据库服务器中。 ​ 其次，开发Docker实例并不像创建一台虚拟机、添加应用然后克隆那样简单。为成功创建并使用Docker基础设施，管理员需要对系统管理的各个方面有一个全面的理解，包括Linux管理、编排及配置工具比如Puppet、Chef以及Salt。这些工具生来就基于命令行以及脚本。 1.4 docker应用场景​ 在docker的网站上提到了docker的典型场景： Automating the packaging and deployment of applications（使应用的打包与部署自动化） Creation of lightweight, private PAAS environments（创建轻量、私密的PAAS环境） Automated testing and continuous integration/deployment（实现自动化测试和持续的集成/部署） Deploying and scaling web apps, databases and backend services（部署与扩展webapp、数据库和后台服务） 二. 安装及使用docker 依赖的基础环境： 64 bits CPU Linux Kernel 3.10+ Linux Kernel cgroups and namespaces CentOS7 “Extras” repositoru Docker Daemon Systemcrl start dorcker Docker Clinet Docker [OPTIONS] CONMMAND [ARG…] 2.1 docker的安装：​ Linux系统自带了docker软件包，但该软件包版本较低，一般不直接安装系统自带的docker。 ​ 我们可以在虚拟机中使用yum repolist命令，同步系统自带的软件包，发现结果都是1.13.1版本的docker，如下图： 12345678910111213141516171819202122232425[root@docker ~]# yum info docker # 查看服务器上的docker信息Loaded plugins: fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.comAvailable PackagesName : docker # 软件包名称Arch : x86_64 # 适用平台Epoch : 2Version : 1.13.1 # docker版本信息Release : 162.git64e9980.el7.centosSize : 18 M # 软件包大小Repo : extras/7/x86_64 # 软件包仓库Summary : Automates deployment of containerized applicationsURL : https://github.com/docker/docker # 软件包的url地址License : ASL 2.0Description : Docker is an open-source engine that automates the deployment of any描述信息 : application as a lightweight, portable, self-sufficient container that will : run virtually anywhere. : : Docker containers can encapsulate any payload, and will run consistently on : and between virtually any server. The same container that a developer builds : and tests on a laptop will run at scale, in production*, on VMs, bare-metal : servers, OpenStack clusters, public instances, or combinations of the above. 接下来，我们来查看阿里镜像网站上的docker的版本信息： 输入网址https://mirrors.aliyun.com/进入阿里镜像网站，选择docker-ce进入子页面(子页面中有Linux、mac、win三个子目录)，选择对应的Linux子目录进入Linux版本的docker目录，接下来选择系统版本(该页面显示主要的Linux发行版)，此处根据Linux系统版本进行选择，点击进入centos子目录，如下图： ​ 我们可以直接配置并使用该仓库进行docker的安装，如下： 1234567891011# 安装前关闭firewalld和selinux[root@docker ~]# yum install -y yum-utils device-mapper-persistent-data lvm2 # 安装必要的软件[root@docker ~]# yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 添加docker仓库，添加完成后就是国内阿里源仓库了，如果下载了国外的docker镜像仓库，可将网址替换成国内源[root@docker ~]# yum clean all &amp;&amp; yum repolistrepo id repo name statusbase/7/x86_64 CentOS-7 - Base - mirrors.aliyun.com 10,070docker-ce-stable/x86_64 Docker CE Stable - x86_64 79epel/x86_64 Extra Packages for Enterprise Linux 7 - x86_64 13,376extras/7/x86_64 CentOS-7 - Extras - mirrors.aliyun.com 412updates/7/x86_64 CentOS-7 - Updates - mirrors.aliyun.com 890repolist: 24,827 # 配置完成后如上所示 ​ 较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。在进行安装之前先卸载系统自带的docker。 1234567[root@docker ~]# rpm -qi docker-ce # 查看docker是否已经安装，如果安装需卸载package docker-ce is not installed[root@docker ~]# rpm -qi dockerpackage docker is not installed# 如果显示已经安装了docker，需要使用下面的命令卸载docker，再安装新版本的docker[root@docker ~]# yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine 安装docker 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@docker ~]# yum -y install docker-ce # 主要安装了如下的软件# 也可以安装指定版本的docker，使用yum时指定版本即可# 查看docker版本信息[root@docker ~]# docker version Client: Docker Engine - Community # docker客户端信息 Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 # 安装时间 OS/Arch: linux/amd64 # 系统类型 Experimental: falseCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?# 提示docker daemon未运行，运行后会显示docker daemon的信息[root@docker ~]# rpm -qi docker-ce # 查看安装的docker-ce信息Name : docker-ceEpoch : 3Version : 19.03.12Release : 3.el7Architecture: x86_64Install Date: Wed 15 Jul 2020 03:32:29 PM CSTGroup : Tools/DockerSize : 106714688License : ASL 2.0Signature : RSA/SHA512, Tue 23 Jun 2020 05:21:51 AM CST, Key ID c52feb6b621e9f35Source RPM : docker-ce-19.03.12-3.el7.src.rpmBuild Date : Mon 22 Jun 2020 11:46:41 PM CSTBuild Host : 7d52e4e2ee0bRelocations : (not relocatable)Packager : Docker &lt;support@docker.com&gt;Vendor : Docker # vendor [ˈvendər] 小贩，这里指软件提供厂商URL : https://www.docker.com # 官方url地址Summary : The open-source application container engineDescription : # 描述信息Docker is a product for you to build, ship and run any application as alightweight container.Docker containers are both hardware-agnostic and platform-agnostic. This meansthey can run anywhere, from your laptop to the largest cloud compute instance andeverything in between - and they don&#x27;t require you to use a particularlanguage, framework or packaging system. That makes them great building blocksfor deploying and scaling web apps, databases, and backend services withoutdepending on a particular stack or provider. ​ 到此，dockers就安装完成了。 ​ 给docker镜像加速，我们在创建容器的时候，是需要到官网上下载指定版本的软件的，因此下载镜像的快慢是我们必须关注的话题，一般可以使用官网的docker cn、阿里云加速器、中国科技大学加速器、163加速器等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119[root@docker ~]# ls /etc/dockerls: cannot access /etc/docker: No such file or directory[root@docker ~]# mkdir /etc/docker[root@docker ~]# vim /etc/docker/daemon.json # 镜像加速，自建该文件&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;]&#125;# 启动docker[root@docker ~]# systemctl start docker &amp;&amp; systemctl enable docker[root@docker ~]# docker versionClient: Docker Engine - Community # docker客户端信息 Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:46:54 2020 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community # docker服务端信息 Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:45:28 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683[root@docker ~]# docker info # docker容器信息Client: Debug Mode: falseServer: Containers: 0 # 容器 Running: 0 # 运行的容器个数 Paused: 0 # 暂停的容器个数 Stopped: 0 # 停止的容器个数 Images: 0 # docker镜像个数 Server Version: 19.03.12 # docker服务端版本 Storage Driver: overlay2 # 存储 Backing Filesystem: xfs # 文件系统 Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: # 插件 Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd init version: fec3683 Security Options: # 安全选项 seccomp Profile: default Kernel Version: 3.10.0-957.el7.x86_64 # 本地服务器内核版本 Operating System: CentOS Linux 7 (Core) # 本地服务器操作系统 OSType: linux # 操作系统类型 Architecture: x86_64 # 本地服务器架构 CPUs: 4 # cpu个数 Total Memory: 7.62GiB # 本地服务器内存大小 Name: docker # 本地服务器主机名 ID: CTSU:SHD4:IUXR:4NUI:BC2G:D2JO:OVS2:2VNN:3OP5:GOV5:EUO7:NI2A Docker Root Dir: /var/lib/docker # docker根目录 Debug Mode: false Registry: https://index.docker.io/v1/ # 默认docker仓库地址 Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Registry Mirrors: # 加速镜像地址 https://registry.docker-cn.com/ # 在/etc/docker/daemon.json定义 http://hub-mirror.c.163.com/ Live Restore Enabled: false[root@docker ~]# ll /var/lib/docker # docker根目录下的文件夹total 4drwx--x--x 4 root root 120 Feb 15 10:49 buildkitdrwx-----x 5 root root 222 Mar 31 19:51 containers # 容器drwx------ 3 root root 22 Feb 15 10:49 image # 镜像drwxr-x--- 3 root root 19 Feb 15 10:49 network # 网络drwx-----x 19 root root 4096 Mar 31 19:51 overlay2drwx------ 4 root root 32 Feb 15 10:49 pluginsdrwx------ 2 root root 6 Mar 31 19:46 runtimesdrwx------ 2 root root 6 Feb 15 10:49 swarmdrwx------ 2 root root 6 Mar 31 19:46 tmpdrwx------ 2 root root 6 Feb 15 10:49 trustdrwx-----x 2 root root 50 Mar 31 19:46 volumes # 存储 # 安装完成后系统上将会多出一个docker0的网络[root@docker ~]# ifconfig docker0 # 该网卡随着容器的运行而运行，如果没用容器运行该网卡状态为downdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:c0ff:febc:f72a prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:c0:bc:f7:2a txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2 bytes 180 (180.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0# 运行容器后，会多出容器的IP信息，网络将后后面的章节详细讲解，这里不赘述 Docker程序环境： 12345678910111213[root@docker ~]# rpm -ql docker-ce # 默认安装的文件如下/usr/bin/docker-init/usr/bin/docker-proxy/usr/bin/dockerd/usr/lib/systemd/system/docker.service/usr/lib/systemd/system/docker.socket# docker的配置文件可手动新建## docker网络文件--/etc/sysconfig/docker-network## docker存储文件--/etc/sysconfig/docker-storage## docker主配置文件--/etc/sysconfig/docker## Docker registry配置文件--/etc/conftainers/registries.conf## Docker镜像加速文件--/etc/docker/daemon.json 2.2 运行容器​ 容器通过镜像启动。镜像出现在Docker生命周期中的构建和打包阶段，容器存在于启动和执行阶段。 ​ 当一个容器启动时，Docker会在镜像的最顶层加载一个读写文件系统。程序就在这一层执行，第一个启动时，这一层是空的，当文件系统变化时，都会应用到这一层。 ​ 写时复制。如果想要修改一文件，就会先将它复制到可写层。 Docker容器的能力 ： 文件系统隔离：每个容器都有自己的root文件系统。 进程隔离：每个容器都运行在自己的进程环境中。 网络隔离：容器间的虚拟网络接口和IP地址都是分开的。 资源隔离和分组：使用cgroups将CPU和内存之间的资源独立分配给每个Docker容器。 2.2.1 运行一次性容器​ 该类型的容器，执行完任务后就自动销毁。 ​ Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。 1234567891011# 我们将分析运行过程[root@docker ~]# docker container run ubuntu:15.10 /bin/echo &quot;Hello world&quot;Unable to find image &#x27;ubuntu:15.10&#x27; locally # 提示本地没有ubuntu:15.10镜像15.10: Pulling from library/ubuntu # 然后从仓库中下载指定镜像7dcf5a444392: Pull complete 759aa75f3cee: Pull complete 3fa871dc8a2b: Pull complete 224c42ae46e7: Pull complete Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3Status: Downloaded newer image for ubuntu:15.10 # 下载镜像完成Hello world # 输出运行结果 各个参数解析： docker: Docker 的二进制执行文件。 run: 与前面的 docker 组合来运行一个容器。 ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。 /bin/echo “Hello world”: 在启动的容器里执行的命令 以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。 运行完成后docker自动停止，因为我们没有让该container一直运行 12345678910111213[root@docker ~]# docker image ls # 镜像 镜像标签 镜像的id 镜像创建时间 镜像大小REPOSITORY TAG IMAGE ID CREATED SIZEubuntu 15.10 9b9cb95443b5 3 years ago 137MB[root@docker ~]# docker container ls # 查看在运行的容器# 容器id 镜像 运行的命令 创建时间 状态 端口 容器名称CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES#[root@docker ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfa95ac9f0d3d ubuntu:15.10 &quot;/bin/echo &#x27;Hello wo…&quot; About a minute ago Exited (0) About a minute ago crazy_lehmann# 注意这里的两个About a minute ago，容器启动并执行了任务后就立马终止，要想不立马启动执行任务完成后就停止，那么就需要使用交互式模式或后台模式启动容器 2.2.2 运行交互式的容器​ 该类型的容器，用户退出容器后，容器自动销毁，只要不退出窗口，容器会一直运行。 ​ 我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现**”对话”**的能力： 常用参数解析： -t: 在新容器内指定一个伪终端或终端 -i: 允许你对容器内的标准输入 (STDIN) 进行交互，一般与-t一起使用 -d：运行容器到后台 -e：设置环境变量，可使用多个-e设置多个环境变量 -p：发布容器端口到主机 -P：发布容器的所有EXPOSE端口到宿主机的随机端口 –name：设置运行容器的名称，唯一标识 -h：设置容器的主机名，不设置的话，默认使用容器id前几位作为主机名，并写入hostname文件中 –ip：指定容器的IP，只能用于自定义网络 –dns：设置容器的DNS，容器默认会加载宿主机的resolv.conf文件 –network：连接容器到一个网络，指定的网络(容器的网络)必须已经存在 –mount：将文件系统附加到容器 -v：绑定挂载一个卷 –restart：容器退出时重启策略，默认为no，可选值为always，no-failure 资源限制参数，如果不限制容器使用的资源，容器默认使用宿主机的所有资源 -m：设置容器能使用的最大内存量 –memory-swap=xxm：运行交换到磁盘的内存量 –memory-swappiness=&lt;0-100&gt;：rongqi 使用swap分区交换百分比，默认为-1 –oom-kill-disable：禁用OOM killer –cpus：容器能够使用的cpu数量 –cpuset-cpus==0-3：限制容器使用特点的cpu核心，如0-3，0，2，注意cpu从0开始计算 –cpu-shares：cpu共享(相对权重) 123456789101112131415161718[root@docker ~]# docker run -i -t ubuntu:15.10 /bin/bashroot@0e2bcf007d3e:/# ls # 该容器的内部文件，显示root@0e2bcf007d3e:/后表示进入到容器内部bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@0e2bcf007d3e:/# uname -aLinux 0e2bcf007d3e 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linuxroot@0e2bcf007d3e:/# echo &quot;hello docker!&quot; # 在容器中执行Linux命令hello docker!root@0e2bcf007d3e:/# exit # 退出后，容器就被销毁了exit# 如果我们又想退出窗口，又不想终止该容器，怎么办呢？# 在容器内部，按住crl键+p+q三个键，先按住ctl键(不松开)，再按p键，最后按q键# 如果还想回到上面的窗口，使用docker container attach +容器id/容器名# 使用docker exec将不能进入之前的窗口，而是打开了一个新窗口 在未退出容器之前，我们重新开一个shell，查看docker的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240[root@docker ~]# docker info # 显示有一个容器运行，一个停止，有一个镜像Client: Debug Mode: falseServer: Containers: 2 Running: 1 Paused: 0 Stopped: 1 Images: 1·····# 查看再运行的容器信息如下[root@docker ~]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0e2bcf007d3e ubuntu:15.10 &quot;/bin/bash&quot; 16 seconds ago Up 15 seconds epic_newton# 查看所有容器(运行和未运行)信息[root@docker ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0e2bcf007d3e ubuntu:15.10 &quot;/bin/bash&quot; 16 seconds ago Up 15 seconds epic_newtonfa95ac9f0d3d ubuntu:15.10 &quot;/bin/echo &#x27;Hello wo…&quot; 11 minutes ago Exited (0) 11 minutes ago crazy_lehmann# 此时查看ip信息，省略lo和ens33两张网卡的信息：[root@docker ~]# ip a·····3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:c0:bc:f7:2a brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:c0ff:febc:f72a/64 scope link valid_lft forever preferred_lft forever9: vethec18bf2@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether aa:5f:ae:2b:63:d6 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::a85f:aeff:fe2b:63d6/64 scope link valid_lft forever preferred_lft forever# 查看容器的详细信息[root@docker ~]# docker inspect 0e2bcf007d3e # 此处的容器id为docker container ls查询出的id，关闭后重启容器，该id值将发生变化[ &#123; &quot;Id&quot;: &quot;0e2bcf007d3e250473914f2214ace1f6d5417357e8f7598cb525ff2f453d3abf&quot;, # 容器id &quot;Created&quot;: &quot;2020-07-15T08:28:12.797341308Z&quot;, # 新建容器时间 &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; # 容器的状态 &quot;Status&quot;: &quot;running&quot;, # 运行 &quot;Running&quot;: true, # 正在运行 &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 35071, # 进行的pid，通过ps -ef | grep 35071 可以查看到该pid的进行信息 &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-07-15T08:28:13.017085499Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: # 容器使用的镜像信息和运行的绝对路径信息 &quot;sha256:9b9cb95443b5f846cd3c8cfa3f64e63b6ba68de2618a08875a119c81a8f96698&quot;, &quot;ResolvConfPath&quot;:# 容器的绝对路径 &quot;/var/lib/docker/containers/0e2bcf007d3e250473914f2214ace1f6d5417357e8f7598cb525ff2f453d3abf/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/0e2bcf007d3e250473914f2214ace1f6d5417357e8f7598cb525ff2f453d3abf/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/0e2bcf007d3e250473914f2214ace1f6d5417357e8f7598cb525ff2f453d3abf/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/0e2bcf007d3e250473914f2214ace1f6d5417357e8f7598cb525ff2f453d3abf/0e2bcf007d3e250473914f2214ace1f6d5417357e8f7598cb525ff2f453d3abf-json.log&quot;, &quot;Name&quot;: &quot;/heuristic_booth&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/ff16a32c0b96e85d19c86a809ffd62d63ad853f11518bdfa6e07b1b30b911c0e-init/diff:/var/lib/docker/overlay2/7b0037a8aafcf18688d9c17601dd4ecc75b6339e7f73a17ab83f26f2922ca9e7/diff:/var/lib/docker/overlay2/eb78645b5c86e6c9dded5eaf9fd15f2007da65e730663deb6b17d455320be3f2/diff:/var/lib/docker/overlay2/ac39c7f3c1f4701de1c3898fa26186579ee523463d88a52857dbe899ae258afe/diff:/var/lib/docker/overlay2/9f19d7f0e3016023666d32dcbd8592355b84ff1056aa1e95085e1e651ee19102/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/ff16a32c0b96e85d19c86a809ffd62d63ad853f11518bdfa6e07b1b30b911c0e/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/ff16a32c0b96e85d19c86a809ffd62d63ad853f11518bdfa6e07b1b30b911c0e/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/ff16a32c0b96e85d19c86a809ffd62d63ad853f11518bdfa6e07b1b30b911c0e/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;0e2bcf007d3e&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: true, &quot;AttachStdout&quot;: true, &quot;AttachStderr&quot;: true, &quot;Tty&quot;: true, &quot;OpenStdin&quot;: true, &quot;StdinOnce&quot;: true, &quot;Env&quot;: [ # 环境变量 &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ # 默认允许的命令 &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;ubuntu:15.10&quot;, # 使用的镜像名称 &quot;Volumes&quot;: null, # 使用卷(存储)信息 &quot;WorkingDir&quot;: &quot;&quot;, # 默认工作目录 &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123;&#125; &#125;, &quot;NetworkSettings&quot;: &#123; # 容器网络设置信息 &quot;Bridge&quot;: &quot;&quot;, # 桥接信息 &quot;SandboxID&quot;: &quot;d1da8aaf46c12ec574ae824e3696bb1a020dda849b720e1673287464aacc2090&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, # 使用的端口 &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/d1da8aaf46c1&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;a9a0746dbcafb0de315968d6b0ed61709584db5b0d3a1325ae4ccef56f799181&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; # 网络详细信息 &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: # 网络id信息 &quot;b474a443cb3eed5a8e5915f61a4be93553de4f17d468d524525d801f1382ccd3&quot;, &quot;EndpointID&quot;: &quot;a9a0746dbcafb0de315968d6b0ed61709584db5b0d3a1325ae4ccef56f799181&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, # 网关地址，即docker0的地址 &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, # 该容器的IP地址 &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, # 容器的mac地址 &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 2.2.3 守护式(后台运行)容器​ 该模式下，容器会一直处于运行状态，除非我们手动终止或设置了终止时间 -d 表示将容器运行于后台，在这个过程中，可以进入容器，也可以停止容器 1234567891011121314151617181920212223242526272829[root@docker ~]# docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; # 以后台模式启动一个容器，让容器一直输出&quot;hello world&quot;a67eafc7e2d056b52adebaeabe968746782efacaa9a2709f1fa8cf002df60448 # 输出了容器的id信息[root@docker ~]# docker ps # 查看正在运行的容器进行信息# 容器 ID 镜像 启动时运行的命令 创建时间 状态 端口或连接类型 容器名称CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa67eafc7e2d0 ubuntu:15.10 &quot;/bin/sh -c &#x27;while t…&quot; About a minute ago Up About a minute charming_leavitt[root@docker ~]# docker logs a67eafc7e2d0 | wc -l # 查看容器的日志信息109[root@docker ~]# docker logs a67eafc7e2d0 | wc -l # 隔1分钟左右后再次查看200# 进入容器内部查看，此处可以用容器id或容器名称，推荐使用exec进入(退出后容器不终止)，而不是attach[root@docker ~]# docker exec -it a67eafc7e2d0 /bin/bash root@a67eafc7e2d0:/# ps -ef # 此时等于是重新开了一个连接终端，查看该容器内的程序UID PID PPID C STIME TTY TIME CMDroot 1 0 0 09:14 ? 00:00:00 /bin/sh -c while true; do echo hello world; sleep 1; done # pid为1进程root 33 0 0 09:15 pts/0 00:00:00 /bin/bash # 这是刚执行进入时打开的shellroot 58 1 0 09:15 ? 00:00:00 sleep 1root 59 33 0 09:15 pts/0 00:00:00 ps -ef # 这是在容器内输入的命令# 使用attach进入连接的是运行pid为1的命令的shell[root@docker ~]# docker attach a67eafc7e2d0hello worldhello worldhello world # 此时一直在输出该信息，退出后容器就终止了# 停止容器，此处可以用容器id或容器名称[root@docker ~]# docker stop a67eafc7e2d0 docker ps 命令中的STATUS: 容器状态解释 状态有7种： created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡） 2.2.4 三种容器运行方式的总结 容器(镜像)是为了完成特定的任务而制作的，任务完成后，容器就应该被停止，基于这种思想，上面三种容器实质上都是一次性容器，只是工作时间长短的区别 如何让一个容器成为一个长时间(永久)运行的容器 以交互式方式启动容器，然后永远不退出当前shell或使用ctrl +p,q退出当前shell 启动容器时给容器执行死循环任务 启动容器时加入后台运行 交互式容器跟后台容器的关系：其实简单来说，后台容器是在交互式容器的基础上加了一个-d参数罢了 值得注意的是，我们仍然可以通过其他的shell通过命令docker attach + 容器id/容器名进入当前容器运行的shell或使用docker exec进入当前shell的子进程，并不是说我们就不能管理该容器 限制容器使用资源的举例： 1234567891011121314151617181920212223242526272829303132333435363738[root@docker20 ~]# docker run -d -m 512m --cpus=&#x27;.5&#x27; nginxdc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b# docker stats + 容器id：显示容器资源的使用率[root@docker20 ~]# docker stats dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86bCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSdc6d2297d670 vibrant_hawking 0.00% 1.945MiB / 512MiB 0.38% 656B / 0B 18.7MB / 21.5kB 2# 修改容器资源限制[root@docker20 ~]# docker update --helpUsage: docker update [OPTIONS] CONTAINER [CONTAINER...]Update configuration of one or more containersOptions: --blkio-weight uint16 Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) --cpu-period int Limit CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota --cpu-rt-period int Limit the CPU real-time period in microseconds --cpu-rt-runtime int Limit the CPU real-time runtime in microseconds -c, --cpu-shares int CPU shares (relative weight) --cpus decimal Number of CPUs --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) --kernel-memory bytes Kernel memory limit -m, --memory bytes Memory limit --memory-reservation bytes Memory soft limit --memory-swap bytes Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap --pids-limit int Tune container pids limit (set -1 for unlimited) --restart string Restart policy to apply when a container exits[root@docker20 ~]# docker update -m 1G dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86bdc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b[root@docker20 ~]# docker stats dc6d2297d670ff91bc2dc1fe0e1f7c38563d6f0279a26e4664d7c87ec96ea86b# 内存值从512M变成了1GCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSdc6d2297d670 vibrant_hawking 0.00% 1.945MiB / 1GiB 0.19% 656B / 0B 18.7MB / 21.5kB 2 2.3 docker生命周期​ Docker采用C/S架构，Docker daemon 作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。 客户端和服务端既可以运行在一个机器上，也可通过 socket 或者RESTful API 来进行通信。 ​ 此处docker生命周期不包含镜像制作，镜像制作请参考后续章节。 docker生命周期全景图 2.3.1 docker客户端命令​ docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。 docker命令解析，下面展示通过三个命令查看docker的命令方法 命令格式：docker [OPTIONS] COMMAND 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[root@VM_16_8_centos ~]# docker [--help]Usage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default &quot;/root/.docker&quot;) -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with &quot;docker context use&quot;) -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/root/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: # 管理命令 builder Manage builds config Manage Docker configs container Manage containers # 管理容器 context Manage contexts engine Manage the docker engine # 管理docker引擎 image Manage images # 管理镜像 network Manage networks # 管理网络 node Manage Swarm nodes plugin Manage plugins # 管理插件 secret Manage Docker secrets service Manage services # 管理服务 stack Manage Docker stacks swarm Manage Swarm system Manage Docker # 管理docker的启停 trust Manage trust on Docker images volume Manage volumes # 管理存储卷Commands: # 这下面的所有命令都可以通过docker COMMAND --help查看更详细命令 attach Attach local standard input, output, and error streams to a running container # 进入本地一个运行的容器 build Build an image from a Dockerfile # 新家一个docker镜像 commit Create a new image from a container&#x27;s changes cp Copy files/folders between a container and the local filesystem create Create a new container # 创建一个容器 diff Inspect changes to files or directories on a container&#x27;s filesystem events Get real time events from the server exec Run a command in a running container # 进入一个运行的容器 export Export a container&#x27;s filesystem as a tar archive history Show the history of an image # 查看docker镜像历史命令 images List images # 列出当前系统上的docker镜像 import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers # 杀掉运行中的容器 load Load an image from a tar archive or STDIN # 从tar文件laod一个镜像 login Log in to a Docker registry # 登录docker hub仓库 logout Log out from a Docker registry # 登出docker hub仓库 logs Fetch the logs of a container # 查看容器日志 pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers # 查看容器进程信息 pull Pull an image or a repository from a registry # 从仓库中下载镜像 push Push an image or a repository to a registry # 将本地镜像推送到仓库，需要先登录，进行认证后才能推送镜像到仓库 rename Rename a container # 重命名容器 restart Restart one or more containers # 重启容器 rm Remove one or more containers # 删除容器 rmi Remove one or more images # 删除镜像 run Run a command in a new container # 运行容器 save Save one or more images to a tar archive (streamed to STDOUT by default) # 将镜像文件保存为tar文件 search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun &#x27;docker COMMAND --help&#x27; for more information on a command. 查看docker container命令的帮助信息 12345678910111213141516171819202122232425262728293031323334[root@VM_16_8_centos ~]# docker container --helpUsage: docker container COMMANDManage containersCommands: attach Attach local standard input, output, and error streams to a running container commit Create a new image from a container&#x27;s changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container&#x27;s filesystem exec Run a command in a running container export Export a container&#x27;s filesystem as a tar archive inspect Display detailed information on one or more containers kill Kill one or more running containers logs Fetch the logs of a container ls List containers pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container prune Remove all stopped containers rename Rename a container restart Restart one or more containers rm Remove one or more containers run Run a command in a new container start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers wait Block until one or more containers stop, then print their exit codesRun &#x27;docker container COMMAND --help&#x27; for more information on a command. 详细解释如下： attach 将本地标准输入、输出和错误流附加到正在运行的容器 commit 根据容器的更改创建新图像 cp 在容器和本地文件系统之间复制文件/文件夹 create 创建新容器 diff 检查对容器文件系统上的文件或目录的更改 exec 在正在运行的容器中运行命令 export 将一个容器的文件系统导出为tar存档，跟save有本质区别 inspect 显示一个或多个容器上的详细信息 kill 杀死一个或多个正在运行的容 logs 获取容器的日志 ls 列表容器 pause 暂停一个或多个容器中的所有进程 port 列表端口映射或容器的特定映射 prune 删除所有停止的容器 rename 重命名容器 restart 重新启动一个或多个容器 rm 移除一个或多个容器 run 运行新容器中命令 start 启动一个或多个停止的容器(容器已存在) stats 显示容器资源使用统计的实时流 stop 停止一个或多个正在运行的容器 top 显示容器的运行进程 unpause 取消暂停一个或多个容器中的所有进程 update 更新一个或多个容器的更新配置 wait 等待块，直到一个或多个容器停止，然后打印它们的退出代码 查看docker container ls命令的帮助信息，通过docker container ls可以查看系统上正在运行的容器，加上选项-a可以查看本机上所有容器(状态为运行中和停止中的容器) 1234567891011121314151617[root@VM_16_8_centos ~]# docker container ls --helpUsage: docker container ls [OPTIONS] # 命令格式List containers # 列出容器Aliases: ls, ps, listOptions: -a, --all Show all containers (default shows just running) # 显示说有容器，包括运行和未运行的 -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) # 指定显示n个最近创建的容器 -l, --latest Show the latest created container (includes all states) # 显示最近创建的容器 --no-trunc Don&#x27;t truncate output -q, --quiet Only display numeric IDs # 只显示容器id -s, --size Display total file sizes # 显示文件大小 2.3.2 获取镜像​ 镜像是容器运行的根本，docker daemon收到用户docker run的命令后，首先检查本地是否存在运行容器的镜像，如果不存在则先向仓库请求下载镜像，下载完成后再运行 下载镜像(由于本地下载半天未下载下来，因此这里选择在腾讯云上下载，下载完成后通过docker save命令将镜像文件保存为tar文件并下载到本地docker测试机上，再通过docker load命令还原成镜像文件) 123456789101112131415161718192021222324252627282930313233343536373839[root@VM_16_8_centos ~]# docker search nginx # 搜索指定名称镜像[root@VM_16_8_centos ~]# docker search nginx --filter=stars=1000 # 搜索星星数大于1000的nginx镜像[root@VM_16_8_centos ~]# docker pull nginx # 从仓库下载镜像Using default tag: latestlatest: Pulling from library/nginx8559a31e96f4: Pull complete 1cf27aa8120b: Pull complete 67d252a8c1e1: Pull complete 9c2b660fcff6: Pull complete 4584011f2cd1: Pull complete Digest: sha256:a93c8a0b0974c967aebe868a186e5c205f4d3bcb5423a56559f2f9599074bbcdStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest[root@VM_16_8_centos ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 4 days ago 132MB[root@docker20 ~]# docker image history nginx # 查看容器制作的历史命令(过程)IMAGE CREATED CREATED BY SIZE COMMENT0901fa9da894 8 months ago /bin/sh -c #(nop) CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon… 0B &lt;missing&gt; 8 months ago /bin/sh -c #(nop) STOPSIGNAL SIGTERM 0B &lt;missing&gt; 8 months ago /bin/sh -c #(nop) EXPOSE 80 0B &lt;missing&gt; 8 months ago /bin/sh -c #(nop) ENTRYPOINT [&quot;/docker-entr… 0B &lt;missing&gt; 8 months ago /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7… 1.04kB &lt;missing&gt; 8 months ago /bin/sh -c #(nop) COPY file:1d0a4127e78a26c1… 1.96kB &lt;missing&gt; 8 months ago /bin/sh -c #(nop) COPY file:e7e183879c35719c… 1.2kB &lt;missing&gt; 8 months ago /bin/sh -c set -x &amp;&amp; addgroup --system -… 63.3MB &lt;missing&gt; 8 months ago /bin/sh -c #(nop) ENV PKG_RELEASE=1~buster 0B &lt;missing&gt; 8 months ago /bin/sh -c #(nop) ENV NJS_VERSION=0.4.2 0B &lt;missing&gt; 8 months ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.19.1 0B &lt;missing&gt; 9 months ago /bin/sh -c #(nop) LABEL maintainer=NGINX Do… 0B &lt;missing&gt; 9 months ago /bin/sh -c #(nop) CMD [&quot;bash&quot;] 0B &lt;missing&gt; 9 months ago /bin/sh -c #(nop) ADD file:4d35f6c8bbbe6801c… 69.2MB # 将该镜像保存为tar文件，并上传到本地服务器使用[root@VM_16_8_centos ~]# docker save -o nginx.tar nginx # save和load是针对镜像导出(入)# -o 表示输出的tar文件名称，后面的nginx表示镜像名称，如果是多个镜像，可继续写镜像名称 导入本地docker测试机后 123456789101112131415161718[root@docker ~]# docker load --help # docker load的用法Usage: docker load [OPTIONS]Load an image from a tar archive or STDINOptions: -i, --input string Read from tar archive file, instead of STDIN -q, --quiet Suppress the load output[root@docker ~]# ll nginx.tar -h -rw-r--r-- 1 root root 131M Jul 15 21:09 nginx.tar[root@docker ~]# ll nginx.tar -h -rw-r--r-- 1 root root 131M Jul 15 21:09 nginx.tar[root@docker ~]# docker load -i nginx.tar 2808ec4a8ea7: Loading layer [==================================================&gt;] 3.584kB/3.584kBLoaded image: nginx:latest[root@docker ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 4 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB 2.3.3 启动容器以下命令使用 nginx镜像启动一个容器，参数为以命令行模式进入该容器： 常用命令参数 -i -t 运行容器后打开交互式终端，进入容器 -d 在后台运行容器，即使用exit命令退出容易也不终止容器的运行 --name 指定容器的名称 -P 暴露随机端口，让外部网络访问，如果不暴露端口，则只有本地主机能访问，外部网络不能访问 -p 8080:80 暴露指定端口，即将主机的8080端口映射给容器的80端口，外露网络通过访问主机ip:8080就可以访问到容器的80端口 容器启动后，默认是可以访问外部网络和本地主机上的其他容器，只是不能被外部访问而已 1[root@docker ~]# docker run -d -P --name webapp nginx:latest /bin/bash 启动容器后，我们可以通过docker ps或docker container ls获取容器的CONTAINER ID或NAMES对容器进行管理 12345678910111213# 只启动容器，不立马进入容器[root@docker ~]# docker container start 79a9b0e8c07479a9b0e8c074# 我们可以在启动容器时，就立马进入容器[root@docker ~]# docker container start -i 79a9b0e8c074[root@docker ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES79a9b0e8c074 0901fa9da894 &quot;/docker-entrypoint.…&quot; 26 hours ago Up 5 seconds 0.0.0.0:32769-&gt;80/tcp webapp[root@docker ~]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES79a9b0e8c074 0901fa9da894 &quot;/docker-entrypoint.…&quot; 26 hours ago Up 14 seconds 0.0.0.0:32769-&gt;80/tcp webapp 2.3.4 获取容器的详细信息 可以获取容器的网络(IP地址)，端口信息(容器端口和主机端口映射关系)，存储，启动容器后运行的脚本等信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235[root@docker ~]# docker container inspect 79a9b0e8c074[ &#123; &quot;Id&quot;: &quot;79a9b0e8c0745bff1f4b4333e53dc738bbb3bf2015591220069fffe010e0024c&quot;, &quot;Created&quot;: &quot;2020-07-15T13:17:36.663642734Z&quot;, &quot;Path&quot;: &quot;/docker-entrypoint.sh&quot;, &quot;Args&quot;: [ &quot;/bin/bash&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 12148, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-07-16T14:51:07.597037016Z&quot;, &quot;FinishedAt&quot;: &quot;2020-07-16T08:29:53.611158447Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0901fa9da894a8e9de5cb26d6749eaffb67b373dc1ff8a26c46b23b1175c913a&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/79a9b0e8c0745bff1f4b4333e53dc738bbb3bf2015591220069fffe010e0024c/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/79a9b0e8c0745bff1f4b4333e53dc738bbb3bf2015591220069fffe010e0024c/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/79a9b0e8c0745bff1f4b4333e53dc738bbb3bf2015591220069fffe010e0024c/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/79a9b0e8c0745bff1f4b4333e53dc738bbb3bf2015591220069fffe010e0024c/79a9b0e8c0745bff1f4b4333e53dc738bbb3bf2015591220069fffe010e0024c-json.log&quot;, &quot;Name&quot;: &quot;/webapp&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: true, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/c2bd00f63da5353bd7378d8cc61428825a6912df7d4915ddd1ccbb1e64c4bcd5-init/diff:/var/lib/docker/overlay2/78476f806a7f8215910d9d6f1a55aa7f432562dc3dca97d28e69f6e2e6d17149/diff:/var/lib/docker/overlay2/9167e98f0c6eedbce79f55ad73db84fdbdc65a80dd0ff8b57e6d068aa8828c8d/diff:/var/lib/docker/overlay2/5908a0b08cecf7d93c0bfc6822ee52af619a872a4196c3091fffa2eb82588b0f/diff:/var/lib/docker/overlay2/dc038e093dc9db0c8996635b1d6cf79dae163ed7cd93922824fef535668fb84e/diff:/var/lib/docker/overlay2/93c919ef9bab4ad8c9b570275d0d8abcc1c530aea546e70630a9d14060b61195/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/c2bd00f63da5353bd7378d8cc61428825a6912df7d4915ddd1ccbb1e64c4bcd5/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/c2bd00f63da5353bd7378d8cc61428825a6912df7d4915ddd1ccbb1e64c4bcd5/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/c2bd00f63da5353bd7378d8cc61428825a6912df7d4915ddd1ccbb1e64c4bcd5/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;79a9b0e8c074&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;80/tcp&quot;: &#123;&#125; &#125;, &quot;Tty&quot;: true, &quot;OpenStdin&quot;: true, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;NGINX_VERSION=1.19.1&quot;, &quot;NJS_VERSION=0.4.2&quot;, &quot;PKG_RELEASE=1~buster&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;nginx:latest&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: [ &quot;/docker-entrypoint.sh&quot; ], &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;maintainer&quot;: &quot;NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;&quot; &#125;, &quot;StopSignal&quot;: &quot;SIGTERM&quot; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;96cf346aca900378933b0b005e8bffdd160b730d5e82121b66202f98d89496b0&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123; &quot;80/tcp&quot;: [ &#123; &quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32769&quot; # 主机映射的端口 &#125; ] &#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/96cf346aca90&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;450ac478bd79a67255d97466ad6eaefbaaecce13ebcb5681d06d334caf9fb4e9&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;f7bbc1dcbfdba55eb6081ac3571fcc6cb9cb5aa03d6e583e564b8901da45ea91&quot;, &quot;EndpointID&quot;: &quot;450ac478bd79a67255d97466ad6eaefbaaecce13ebcb5681d06d334caf9fb4e9&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, # 容器使用的IP地址 &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;]# 查看端口映射信息[root@docker ~]# docker port 79a9b0e8c07480/tcp -&gt; 0.0.0.0:32769 # 标识127.17.0.2:80端口映射到主机的32769端口# 我们可以在本机上(如果不使用-p或-P参数，将只能在本机访问)访问nginx，如下：[root@docker ~]# curl -I 172.17.0.2HTTP/1.1 200 OKServer: nginx/1.19.1Date: Thu, 16 Jul 2020 15:04:03 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Tue, 07 Jul 2020 15:52:25 GMTConnection: keep-aliveETag: &quot;5f049a39-264&quot;Accept-Ranges: bytes 外部访问nginx访问： 2.3.5 停止容器12345[root@docker ~]# docker container stop 79a9b0e8c07479a9b0e8c074 # 命令中的container可以忽略不写# 使用Kill命令暴力终止容器[root@docker ~]# docker container kill 79a9b0e8c074 2.3.6 重启容器或启动停止的容器12345678910111213141516171819# 启动停止的容器[root@docker ~]# docker container start 79a9b0e8c07479a9b0e8c074[root@docker ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES79a9b0e8c074 nginx:latest &quot;/docker-entrypoint.…&quot; 5 minutes ago Up 2 seconds 0.0.0.0:32771-&gt;80/tcp webapp# 此时可以查看本地服务器32771端口使用情况[root@docker ~]# ps -ef | grep 32771# 此处表明本地端口跟容器端口做了映射root 20003 9219 0 21:23 ? 00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 32771 -container-ip 172.17.0.2 -container-port 80# 我们也可以使用下面的命令查看指定容器端口映射情况[root@docker ~]# docker container port 79a9b0e8c07480/tcp -&gt; 0.0.0.0:32771 # 上面命令中的container可省略不写# 重启一个容器[root@docker ~]# docker container restart 79a9b0e8c07479a9b0e8c074 # 上面命令中的container可省略不写 2.3.7 进入容器​ 在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach + 容器id docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。 1234567[root@docker ~]# docker attach 79a9b0e8c074# 注意：如果从这个容器退出，会导致容器的停止# 如果多个用户使用该方式进入容器，其实进入的是同一个shell，可以看到的是同一个屏幕# 使用exec进入容器，需要使用-it和/bin/bash重新分配一个终端，# 该方式等于是以子进程的方式进入容器，常用于容器的管理[root@docker ~]# docker exec -it 79a9b0e8c074 /bin/bash 2.3.8 导入和导出容器​ 这种方式常用于由于网络原因，在两台服务器之间的镜像导入和导出，亦或将外网镜像导入到内网环境中。 123456# 将docker镜像导出为tar文件，这里涉及了一个问题如何准确找到指定镜像[root@VM_16_8_centos ~]# docker save -o nginx.tar nginx:latest# 上述命令等同于docker image save 0901fa9da894 &gt; /tmp/nginx.tar# 将tar文件导出为docker镜像[root@docker ~]# docker load -i nginx.tar 2.3.9 删除容器 值得注意的是，无论我们使用哪种方式启动容器，然后停止容器后，容器都存在于本机中，后续我们可以继续启动某个容器，即只要我们不执行删除操作，容器会一直存在于本地服务器上，长期占用本地磁盘空间 执行删除指定容器的命令 12[root@docker ~]# docker container rm 79a9b0e8c07479a9b0e8c074 # 直接将运行的容器杀掉，container可省略不写 启动容器时，指定容器运行完成后删除容器 123456789101112[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEscaven/nginx 1.2 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB# 在执行完任务后，退出容器就直接删除容器，常用于开发、测试、临时性任务等[root@docker ~]# docker container run -it --name ubuntu --rm 9b9cb95443b5root@6eff441bf994:/# echo $HOSTNAME 6eff441bf994root@6eff441bf994:/# exitexit# 此时通过docker container ls -a查看将查询不到一个名叫ubuntu的容器 删除本机上的所有容器 1[root@docker ~]# docker container rm `docker container ls -a -q` 三. docker镜像​ 镜像是容器的基石，容器基于镜像启动和运行。镜像保存的容器启动的各种条件。Docker Image是一个层叠的只读文件系统。 ​ 如上图所示，容器启动时，从下而上加载需要的镜像，镜像被依次移到内存中，最后，bootfs（引导文件系统）会被卸载。 ​ 在Docker中，rootfs（root文件系统）永远只读，利用联合加载技术，在root文件系统的基础上加载更多的只读文件系统。将这样的文件系统称之为镜像，对，没错，镜像就是一堆文件系统的集合。 ​ 联合加载技术是一次加载多个文件系统，但是在外面看来好像只有一个文件系统。最终将各层文件叠加到一起，最终的文件系统包含所有的底层文件和目录。 ​ 一个镜像可以放到另一个镜像的顶部，称为下一个镜像的父镜像。最底部的镜像称为基础镜像。 3.1 docker镜像仓库​ 镜像仓库(用于镜像存放)官网：https://hub.docker.com/ 官网的使用和简介： 搜索指定镜像，任何人都可以注册使用docker镜像仓库，上传下载和使用镜像 点击进入官方nginx镜像仓库： 查看”Reviews”–展示用户对镜像的评价信息 选择‘Tags’查看–展示镜像的所有标签信息 唯一标识一个镜像的方法： 镜像id：sha256:64位，默认只截取12位 镜像仓库:tag 3.2 docker镜像相关命令有关镜像的相关命令： 12345678910111213141516171819202122[root@docker ~]# docker image --helpUsage: docker image COMMANDManage imagesCommands: build Build an image from a Dockerfile history Show the history of an image import Import the contents from a tarball to create a filesystem image inspect Display detailed information on one or more images load Load an image from a tar archive or STDIN ls List images prune Remove unused images pull Pull an image or a repository from a registry push Push an image or a repository to a registry rm Remove one or more images save Save one or more images to a tar archive (streamed to STDOUT by default) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGERun &#x27;docker image COMMAND --help&#x27; for more information on a command. 详细解释如下 build Build an image from a Dockerfile 从Dockerfile生成图像 history Show the history of an image 历史展示一个镜像的历史 import Import the contents from a tarball to create a filesystem image 导入从tarball导入内容以创建文件系统镜像 inspect Display detailed information on one or more images 检查显示一个或多个镜像的详细信息 load Load an image from a tar archive or STDIN 从tar存档或stdin加载镜像 ls List images 列出系统上现有的镜像 prune Remove unused images 删除未使用的镜像 pull Pull an image or a repository from a registry 从仓库中拉取镜像 push Push an image or a repository to a registry 将镜像推送到远端仓库中 rm Remove one or more images rm删除一个或多个镜像 save Save one or more images to a tar archive (streamed to STDOUT by default) 将一个或多个镜像保存到tar存档（默认情况下流式传输到stdout） tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE 给镜像打标签 docker 镜像常用操作： 3.2.1 下载镜像首先，我们可以去docker hub官网进行查找指定镜像，如我们查找centos 7.6的镜像，找到后就可以直接复制红框中的命令进行下载 12345678910111213141516171819202122232425262728293031# 当然，我们也可以在测试机上进行简单的搜索，如下，不过不指定版本，就是下载最新版[root@VM_16_8_centos ~]# docker search centosNAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 6090 [OK] ansible/centos7-ansible Ansible on Centos7 132 [OK]····# 下载centos官方镜像[root@VM_16_8_centos ~]# docker pull centos # 下载最新版latest: Pulling from library/centos6910e5a164f7: Pull complete Digest: sha256:4062bbdd1bb0801b0aa38e0f83dece70fb7a5e9bce223423a68de2d8b784b43bStatus: Downloaded newer image for centos:latestdocker.io/library/centos:latest# 下载后的镜像一般存储在/var/lib/docker中[root@VM_16_8_centos ~]# ls /var/lib/dockerbuilder buildkit containers image network overlay2 plugins runtimes swarm tmp trust volumes[root@VM_16_8_centos ~]# docker pull centos:centos7.6.1810 # 下载指定版本centos7.6.1810: Pulling from library/centosac9208207ada: Pull complete Digest: sha256:62d9e1c2daa91166139b51577fe4f4f6b4cc41a3a2c7fc36bd895e2a17a3e4e6Status: Downloaded newer image for centos:centos7.6.1810docker.io/library/centos:centos7.6.1810[root@VM_16_8_centos ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 5 days ago 132MBcentos latest 831691599b88 4 weeks ago 215MBcentos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MB 3.2.2 打标签 命令格式：docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] 等同于：docker image tag SOURCE_IMAGE_ID TARGET_IMAGE[:TAG] 12345678910111213141516[root@docker ~]# docker image tag --helpUsage: docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB# [root@docker ~]# docker image tag 0901fa9da894 scaven/nginx:1.1.1[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 5 days ago 132MBscaven/nginx 1.1.1 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB 3.2.3 删除镜像 建议使用镜像:标签或者镜像ID来删除镜像，因为这样才是唯一标识了一个镜像 格式：docker image rm [OPTIONS] IMAGE [IMAGE…] 1234567891011121314151617181920212223242526272829303132333435# 使用镜像ID删除镜像[root@docker ~]# docker image rm 0901fa9da894Error response from daemon: conflict: unable to delete 0901fa9da894 (must be forced) - image is referenced in multiple repositories# 报错的意思是该镜像id标识了两个仓库的镜像，因此不能使用该方法删除，由此可知要删除两个镜像id一样的镜像，只能使用`镜像仓库:标签`的方法[root@docker ~]# docker image rm scaven/nginx:1.1.1Untagged: scaven/nginx:1.1.1[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB[root@docker ~]# docker image rm 0901fa9da894Error response from daemon: conflict: unable to delete 0901fa9da894 (must be forced) - image is being used by stopped container 2a2bbb830211# 报错是指，该镜像关联了一个停止中的容器，需要使用-f参数才能强制删除，如果是一个运行中的容器，不能强制删除# 使用-f参数，强制删除容器镜像[root@docker ~]# docker image rm -f 0901fa9da894Untagged: nginx:latestDeleted: sha256:0901fa9da894a8e9de5cb26d6749eaffb67b373dc1ff8a26c46b23b1175c913a[root@docker ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZEubuntu 15.10 9b9cb95443b5 3 years ago 137MB# 重启被删除镜像的容器，容器运行正常[root@docker ~]# docker container start 79a9b0e8c07479a9b0e8c074[root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES79a9b0e8c074 0901fa9da894 &quot;/docker-entrypoint.…&quot; 19 hours ago Up 39 seconds 0.0.0.0:32768-&gt;80/tcp webapp# 删除全部镜像[root@docker ~]# docker image rm -f `docker image ls -q`# `docker image ls -q`命令是显示所有镜像的镜像ID 3.2.4 导入和导出镜像 导出镜像：docker image save -o IMAGE.tar IMAGE [IMAGE…] 导入镜像：docker image load -i IMAGE.tar 1234567891011121314151617181920# 在删除nginx镜像之前做了导出镜像，如下[root@docker ~]# docker image save 0901fa9da894 &gt; /tmp/nginx.tar[root@docker ~]# ls /tmp/nginx.tar /tmp/nginx.tar# 导入镜像[root@docker ~]# docker load -i /tmp/nginx.tarLoaded image ID: sha256:0901fa9da894a8e9de5cb26d6749eaffb67b373dc1ff8a26c46b23b1175c913a[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB# 使用docker image save 0901fa9da894 &gt; /tmp/nginx.tar这个命令导出的镜像文件在导入时，不能继承源镜像的仓库和标签，需要收到打标签# 给没有指定仓库和标签的镜像打标签，此处只能使用镜像ID来标识该镜像[root@docker ~]# docker image tag 0901fa9da894 scaven/nginx:1.2 [root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEscaven/nginx 1.2 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB 3.2.5 上传自制镜像到docker官方仓库 此处以centos镜像为例，首先创建镜像仓库 创建完成后，如下： 接下来我们上传镜像到scaven/os仓库中 1234567891011121314151617181920212223242526# 首先登录docker官方仓库[root@VM_16_8_centos ~]# docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.Username: scaven # 输入用户名Password: # 输入密码WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded # 提示登录成功# 登录成功后，就可以推送镜像到docker hub中[root@VM_16_8_centos ~]# docker image tag centos:centos7.6.1810 scvaen/os:centos7.6.1810# 将本地镜像中的仓库名称修改成镜像仓库中的仓库名称[root@VM_16_8_centos ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 5 days ago 132MBcentos latest 831691599b88 4 weeks ago 215MBcentos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MBscaven/os centos7.6.1810 f1cb7c7d58b7 16 months ago 202MB[root@VM_16_8_centos ~]# docker push scaven/os:centos7.6.1810The push refers to repository [docker.io/scaven/os]89169d87dbe2: Mounted from library/centos centos7.6.1810: digest: sha256:747b2de199b6197a26eb1a24d69740d25483995842b2d2f75824095e9d1d19eb size: 529 命令执行成功后，我们可以在镜像仓库中查看到已经上传的镜像信息，如下 3.2.6 查看下载镜像的详细信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEscaven/nginx 1.2 0901fa9da894 5 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB[root@docker ~]# docker image inspect 0901fa9da894 [ &#123; &quot;Id&quot;: &quot;sha256:0901fa9da894a8e9de5cb26d6749eaffb67b373dc1ff8a26c46b23b1175c913a&quot;, &quot;RepoTags&quot;: [ # 镜像标签新信息 &quot;scaven/nginx:1.2&quot; ], &quot;RepoDigests&quot;: [], &quot;Parent&quot;: &quot;&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2020-07-10T20:26:44.624785651Z&quot;, # 创建时间 &quot;Container&quot;: &quot;348c3ade7f4bdc0366f3f390ea4cfaebfb355ad7d621547eaf73728136d3bd2d&quot;, &quot;ContainerConfig&quot;: &#123; # 容器配置信息 &quot;Hostname&quot;: &quot;348c3ade7f4b&quot;, # 启动后的主机名--镜像ID前12位 &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;80/tcp&quot;: &#123;&#125; # 启动的端口 &#125;, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ # 容器环境变量信息 &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;NGINX_VERSION=1.19.1&quot;, &quot;NJS_VERSION=0.4.2&quot;, &quot;PKG_RELEASE=1~buster&quot; ], &quot;Cmd&quot;: [ # 启动后指定的指定命令 &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop) &quot;, &quot;CMD [\\&quot;nginx\\&quot; \\&quot;-g\\&quot; \\&quot;daemon off;\\&quot;]&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:8a6dfc8c21a1b3f3679b7755fc7869a22b5f8583778cf7835b5ee5387a73ae5e&quot;, &quot;Volumes&quot;: null, # 存储卷信息 &quot;WorkingDir&quot;: &quot;&quot;, # 工作目录 &quot;Entrypoint&quot;: [ &quot;/docker-entrypoint.sh&quot; ], &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;maintainer&quot;: &quot;NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;&quot; &#125;, &quot;StopSignal&quot;: &quot;SIGTERM&quot; &#125;, &quot;DockerVersion&quot;: &quot;18.09.7&quot;, # docker版本信息 &quot;Author&quot;: &quot;&quot;, &quot;Config&quot;: &#123; # 配置信息 &quot;Hostname&quot;: &quot;&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;80/tcp&quot;: &#123;&#125; &#125;, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;NGINX_VERSION=1.19.1&quot;, &quot;NJS_VERSION=0.4.2&quot;, &quot;PKG_RELEASE=1~buster&quot; ], &quot;Cmd&quot;: [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:8a6dfc8c21a1b3f3679b7755fc7869a22b5f8583778cf7835b5ee5387a73ae5e&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: [ &quot;/docker-entrypoint.sh&quot; ], &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;maintainer&quot;: &quot;NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;&quot; &#125;, &quot;StopSignal&quot;: &quot;SIGTERM&quot; &#125;, &quot;Architecture&quot;: &quot;amd64&quot;, # 架构 &quot;Os&quot;: &quot;linux&quot;, # 操作系统 &quot;Size&quot;: 132484492, # 镜像大小 &quot;VirtualSize&quot;: 132484492, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/9167e98f0c6eedbce79f55ad73db84fdbdc65a80dd0ff8b57e6d068aa8828c8d/diff:/var/lib/docker/overlay2/5908a0b08cecf7d93c0bfc6822ee52af619a872a4196c3091fffa2eb82588b0f/diff:/var/lib/docker/overlay2/dc038e093dc9db0c8996635b1d6cf79dae163ed7cd93922824fef535668fb84e/diff:/var/lib/docker/overlay2/93c919ef9bab4ad8c9b570275d0d8abcc1c530aea546e70630a9d14060b61195/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/78476f806a7f8215910d9d6f1a55aa7f432562dc3dca97d28e69f6e2e6d17149/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/78476f806a7f8215910d9d6f1a55aa7f432562dc3dca97d28e69f6e2e6d17149/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/78476f806a7f8215910d9d6f1a55aa7f432562dc3dca97d28e69f6e2e6d17149/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;RootFS&quot;: &#123; &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:13cb14c2acd34e45446a50af25cb05095a17624678dbafbcc9e26086547c1d74&quot;, &quot;sha256:0e32546a8af0cd04ad451d6a9d22e650e500e5da3636a32648c9f5aca96a0ff7&quot;, &quot;sha256:7ef35766ef7d5d3d958022405b308d5c105b41190e1b63b2037c4055c6950c9e&quot;, &quot;sha256:4856db5e4f59384c413c20c46cd5403a860e1b07c8fdbad24df1ffd9209d44e7&quot;, &quot;sha256:2808ec4a8ea71c2660284d06cf7e25354b70b58504edb46ac3e705fb7e6ea519&quot; ] &#125;, &quot;Metadata&quot;: &#123; # 元数据 &quot;LastTagTime&quot;: &quot;2020-07-16T16:30:36.781611539+08:00&quot; &#125; &#125;] 四. docker容器网络​ Docker使用Linux桥接（参考《Linux虚拟网络技术》），在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。 ​ Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。 ​ 查看docker network相关命令 123456789101112131415161718192021[root@docker ~]# docker network lsNETWORK ID NAME DRIVER SCOPEad1f746530ad bridge bridge local # 桥接模式，默认86c30ec76685 host host local # 开放式容器模式c2385d5ccbf9 none null local # 封闭式容器模式[root@docker ~]# docker network --helpUsage: docker network COMMANDManage networksCommands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networksRun &#x27;docker network COMMAND --help&#x27; for more information on a command.# docker network inspect bridge # 查看容器网络的详细信息 4.1 四类网络模式 Docker网络模式 配置 说明 host模式(开放式容器) –net=host 容器和宿主机共享Network namespace。 container模式(联盟式容器) –net=container:NAME_or_ID 如上图所示，容器和另外一个容器共享Network namespace，使用同一块网卡，各容器相互间可以使用lo进行同信。 kubernetes中的pod就是多个容器共享一个Network namespace。 none模式(封闭式容器) –net=none 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等，即网络孤岛，没有网络流量进出。 bridge模式(桥接式容器) –net=bridge 拥有一个lo回环网卡和私有网络接口，默认模式 4.1.1 host模式​ 如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP、端口和主机名等。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 ​ 使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。 Host模式如下图所示： Host模式 我们以host模式启动一个容器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091[root@docker ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZEscaven/nginx 1.2 0901fa9da894 6 days ago 132MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB[root@docker ~]# docker run -d -it --name web_n1 --net=host 0901fa9da89406b4c8ad24f39b5e5ca1595b66eaf2227eb4fb994460f5697fa35d876fae5576# 容器内部跟宿主机很像，可以通过敲docker命令区分，宿主机有该命令，容器无该命令# 宿主机的当前目录为/root--[root@docker ~]#，而容器的当前目录是/--[root@docker /]#[root@docker ~]# docker container inspect 06b4c8ad24f3···· &quot;Networks&quot;: &#123; &quot;host&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;86c30ec766859f24472ff5508cf08cbd5924a38b954e823f4e46da6c41fb2cb8&quot;, &quot;EndpointID&quot;: &quot;d21e11627b5a1bd4a7e96ba8c0b4bcbd01aa1fce8517742464e6e96545a019bc&quot;, &quot;Gateway&quot;: &quot;&quot;, # 未显示网关地址 &quot;IPAddress&quot;: &quot;&quot;, # 未显示IP地址 &quot;IPPrefixLen&quot;: 0, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;&quot;, &quot;DriverOpts&quot;: null &#125; &#125;[root@docker ~]# docker port 06b4c8ad24f3 # 没有端口映射，即容器将使用宿主机的端口# 查看本地端口使用情况[root@docker ~]# netstat -lntp # 本地的80端口被使用，如下Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 19590/nginx: master # 占用宿主机端口80tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 9446/master tcp 0 0 0.0.0.0:10022 0.0.0.0:* LISTEN 9191/sshd tcp6 0 0 :::80 :::* LISTEN 19590/nginx: master tcp6 0 0 ::1:25 :::* LISTEN 9446/master tcp6 0 0 :::10022 :::* LISTEN 9191/sshd [root@docker ~]# ip a # 此处没有多出容器的IP地址，若此时进入容器06b4c8ad24f3内，看到的信息跟此处的信息一样1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:64:2a:59 brd ff:ff:ff:ff:ff:ff inet 10.138.3.15/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::b6e4:fced:d3d3:35ee/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:36:01:0b:3f brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever# 进入容器查看ip a的输出[root@docker /]# ip a # 跟在宿主机里面执行ip a得到的结果一样，-- 容器内的当前目录是根1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:64:2a:59 brd ff:ff:ff:ff:ff:ff inet 10.138.3.15/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::b6e4:fced:d3d3:35ee/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:36:01:0b:3f brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever# 我们直接访问nginx[root@docker ~]# curl -I 10.138.3.15:80 # 使用宿主机IP地址和端口访问nginxHTTP/1.1 200 OKServer: nginx/1.19.1Date: Fri, 17 Jul 2020 06:18:20 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Tue, 07 Jul 2020 15:52:25 GMTConnection: keep-aliveETag: &quot;5f049a39-264&quot;Accept-Ranges: bytes 下面，我们通过浏览器直接访问nginx访问： ​ 由此，我们就印证了容器以host模式运行时，容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 4.1.2 container模式–常用于k8s中​ 这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、主机名、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。 Container模式示意图： Container网络模式 案例展示： 123456789101112131415161718192021222324252627282930313233343536[root@docker ~]# docker run -it --name centos7.6 --net=container:web_n1 f1cb7c7d58b7[root@docker /]# ip a # 请注意，这里我们已经进入了容器内，工作目录发生了变化bash: ip: command not found[root@docker /]# ifconfig bash: ifconfig: command not found# 由于查看不到IP地址，因此我们先安装软件包[root@docker /]# yum -y install net-tools [root@docker /]# ifconfig # 由下可知，使用的仍然是主机的网络名称空间docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:36:01:0b:3f txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B)A RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.138.3.15 netmask 255.255.255.0 broadcast 10.138.3.255 inet6 fe80::b6e4:fced:d3d3:35ee prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:64:2a:59 txqueuelen 1000 (Ethernet) RX packets 171689 bytes 239863139 (228.7 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 44482 bytes 3775713 (3.6 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 20 bytes 1700 (1.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 20 bytes 1700 (1.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ​ 宿主机网络和centos7.6容器网络截图比较如下(容器web_n1由于只有nginx的最小运行环境，因此没有yum命令，也没有网络相关命令，因此此处就直接跟宿主机网络做比较了)： 4.1.3 none模式​ 使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 ​ 这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过–network=none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性，因此常用于不需要网络的情况下。 None模式示意图: None网络模式 4.1.4 bridge模式(默认模式)​ 当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。 ​ 从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。 ​ bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。 bridge模式如下图所示： Docker的网络实现 案例展示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[root@docker ~]# docker container rm `docker container ls -a -q` # 删除本地服务器上的所有容器# 启动桥接式容器前宿主机上的网络信息如下[root@docker ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:64:2a:59 brd ff:ff:ff:ff:ff:ff inet 10.138.3.15/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::b6e4:fced:d3d3:35ee/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:36:01:0b:3f brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever# 以默认网络模式启动容器[root@docker ~]# docker run -d --name web_n1 0901fa9da894 fd963117694015a936e5cb3068b99642460c000f01e0a69b2715af5995700c1d# 以默认网络模式启动容器后，会多出一个网卡[root@docker ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:64:2a:59 brd ff:ff:ff:ff:ff:ff inet 10.138.3.15/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::b6e4:fced:d3d3:35ee/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:36:01:0b:3f brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:36ff:fe01:b3f/64 scope link valid_lft forever preferred_lft forever7: vethadf4fe6@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether ba:76:a8:62:25:f5 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::b876:a8ff:fe62:25f5/64 scope link valid_lft forever preferred_lft forever# 此时容器对外网络是连通的，宿主机以外的外部网络不能访问容器，除非暴露端口，该宿主机上的容器可以相互访问[root@docker ~]# ping 127.17.0.2PING 127.17.0.2 (127.17.0.2) 56(84) bytes of data.64 bytes from 127.17.0.2: icmp_seq=1 ttl=64 time=0.033 ms64 bytes from 127.17.0.2: icmp_seq=2 ttl=64 time=0.055 ms^C--- 127.17.0.2 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 0.033/0.044/0.055/0.011 ms[root@docker ~]# iptables -t nat -vnLChain PREROUTING (policy ACCEPT 47 packets, 6015 bytes) pkts bytes target prot opt in out source destination 9 468 DOCKER all -- * * 0.0.0.0/0 0.0.0.0/0 ADDRTYPE match dst-type LOCALChain INPUT (policy ACCEPT 47 packets, 6015 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 84 packets, 5287 bytes) pkts bytes target prot opt in out source destination 2 120 DOCKER all -- * * 0.0.0.0/0 !127.0.0.0/8 ADDRTYPE match dst-type LOCALChain POSTROUTING (policy ACCEPT 84 packets, 5287 bytes) # 该命令展示结果如下图所示 pkts bytes target prot opt in out source destination 0 0 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 Chain DOCKER (2 references) pkts bytes target prot opt in out source destination 0 0 RETURN all -- docker0 * 0.0.0.0/0 0.0.0.0/0 ​ 上文iptables转发如下图所示： 外网如何访问容器？通过端口映射以及选项指定映射端口 外网访问容器用到了docker-proxy和iptables DNAT 宿主机访问本机容器使用的是iptables DNAT外部主机访问容器或容器之间的访问是docker-proxy实现 4.2 桥接模式下暴露端口docker run [-p/-P] ：为容器暴露的所有端口进行映射。 -P：将容器内部开放的网络端口随机映射到宿主机的一个端口上。 -p：指定要映射的端口，可以指定宿主机上的端口，容器的端口或两者都指定。 有四种方式： ContainerPortdocker run -p 80 -i -t IMAGE /bin/bash指定容器端口，宿主机端口随机映射 hostPort:Container:Portdocker run -p 8080:80 -i -t IMAGE /bin/bash同时指定宿主机和容器的端口 ip::containerPortdocker run -p 0.0.0.0:80 -i -t IMAGE /bin/bash ip:hostPort:containerPortdocker run -p 0.0.0.0:8080:80 -i -t IMAGE /bin/bash指定ip，宿主机端口，容器的端口 4.2.1 暴露随机端口 -P的使用方法：将容器内开放的端口随机映射到宿主机的高位端口上，通过访问宿主机的该端口就能访问到容器中的相应的服务。 123456789[root@docker ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEscaven/nginx 1.2 0901fa9da894 6 days ago 132MBcentos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB[root@docker ~]# docker run -d -P --name web01 0901fa9da894 # 启动容器3f1cbb448709d5d7a22e56c5b505ca1fcce972e7daf14e33a23a58125ae7bb18# 为了方便解释，下面将进行截图展示结果 此时查看防火墙转发规则如下： 由于已经暴露了端口，因此可以进行远程访问nginx服务： -p：使用-p 容器端口进行随机端口映射 1234567[root@docker ~]# docker run -d -p 80 --name web03 0901fa9da8946cdfd996b45cdddf670666f0697db57b500cbfa189646ab4910cdf485bf826e2[root@docker ~]# docker port 6cdfd996b45c80/tcp -&gt; 0.0.0.0:32769[root@docker ~]# iptables -t nat -vnL 此时查看防火墙转发规则如下： 主机上端口的使用情况： -p：使用-p ip::容器端口进行随机端口映射 12345678[root@docker ~]# docker run -d -p 127.0.0.1::80 --name web04 0901fa9da8945a1d7105ef29a9ad9e4b31e05f2487427564beed1de185f378ad3223c53eeff9[root@docker ~]# docker port 5a1d7105ef2980/tcp -&gt; 127.0.0.1:32770[root@docker ~]# iptables -t nat -vnL# 由于是暴露了127.0.0.1:32700端口，因此只能本机访问 此时查看防火墙转发规则和主机端口映射情况如下： 4.2.3 暴露指定端口 -p：使用-p 宿主机端口:容器端口进行指定端口映射 1234[root@docker ~]# docker run -d -p 8080:80 --name web02 0901fa9da8943a51900386cb2962e8bc52ba19e64fe8554bd29965b00170c426cfe87b6eab07[root@docker ~]# docker port 3a51900386cb80/tcp -&gt; 0.0.0.0:8080 端口映射情况如下图所示： 主机上端口的使用情况： p：使用-p 宿主机IP:宿主机端口:容器端口进行指定端口映射 1234[root@docker ~]# docker run -d -p 10.138.3.15:9999:80 --name web06 0901fa9da89495b7279dbe9d046b98e59c37ba222c76b727842c71bcb75b9dfca78f2852cd2f[root@docker ~]# docker port 95b7279dbe9d80/tcp -&gt; 10.138.3.15:9999 防火墙转发规则如下： 外部访问： 4.3 跨主机间的docker网络–macvlan​ macvlan可以实现两台主机上的容器相互访问，做法是在两台宿主机上都新建macvlan类型的网络，macvlan等同于将在两台宿主机之间新建了一个用于容器通信的交换机。 步骤： 新建网络类型 创建新容器时指定该类型的网络 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 在两台宿主机上分别执行以下的命令[root@harbor ~]# docker network create --driver macvlan --subnet=10.0.0.0/24 --gateway=10.0.0.254 -o parent=ens33 macvlan_14e2b6de803cc06d2cbed2823f46175c6f2fd82fd758e0fb862872359a6e17420[root@docker ~]# docker network create --driver macvlan --subnet=10.0.0.0/24 --gateway=10.0.0.254 -o parent=ens33 macvlan_1c44710c51f5fb2abdeec89920df103b4aac71b5986ca478e9d118818d09f614f# 新建成功后，可以看到多了一个网络类型[root@docker ~]# docker network lsNETWORK ID NAME DRIVER SCOPEb7becea03c6a bridge bridge local86c30ec76685 host host localc44710c51f5f macvlan_1 macvlan localc2385d5ccbf9 none null local# 新建容器[root@docker ~]# docker run -it --network macvlan_1 centos:centos6.10 /bin/bash[root@4017011864b7 /]# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:0A:00:00:01 inet addr:10.0.0.1 Bcast:10.0.0.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)# 在另一台主机上新建容器[root@harbor ~]# docker run -it --network macvlan_1 centos:centos6.10 /bin/bash[root@f1486558f4e7 /]# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:0A:00:00:01 inet addr:10.0.0.1 Bcast:10.0.0.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b) ​ 此时，我们可以看到，如果不手动指定容器的IP地址，将都分配10.0.0.1的IP地址(没有统一的网络管理，需人工手动指定IP地址，因此使用较少)，因此下面我们在启动容器时，指定容器的IPi地址 1234567891011121314151617181920212223242526272829303132333435# 启动容器时通过--ip=xx.xx.xx.xx指定IP地址[root@docker ~]# docker run -it --network macvlan_1 --ip=10.0.0.11 centos:centos6.10 /bin/bash[root@e74abdd244aa /]# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:0A:00:00:0B inet addr:10.0.0.11 Bcast:10.0.0.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)# 下面启动一个centos7.6的镜像，7.6有ping命令，可以用于测试网络[root@docker ~]# docker run -it --network macvlan_1 --ip=10.0.0.12 centos:centos7.6.1810 /bin/bash [root@9ce61bc01548 /]# ping 10.0.0.11 # 可以ping通另一台主机上的容器PING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=0.178 ms64 bytes from 10.0.0.11: icmp_seq=2 ttl=64 time=0.090 ms^C--- 10.0.0.11 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1001msrtt min/avg/max/mdev = 0.090/0.134/0.178/0.044 ms[root@9ce61bc01548 /]# ping baidu.com # 不能访问外网ping: baidu.com: Name or service not known[root@9ce61bc01548 /]# ping 10.138.3.13 # 不能访问宿主机PING 10.138.3.13 (10.138.3.13) 56(84) bytes of data.From 10.0.0.12 icmp_seq=1 Destination Host Unreachable 4.4 docker容器的一般性管理​ docker容器由于只有程序运行的最小环境，因此我们进入容器后，很难使用管理命令进行查询(命令未安装)，因此，一般情况下我们对容器的管理都是在宿主机上直接管理，而不是进入容器内。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@docker ~]# docker ps # 查看主机上的容器进程CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES95b7279dbe9d 0901fa9da894 &quot;/docker-entrypoint.…&quot; 12 minutes ago Up 12 minutes 10.138.3.15:9999-&gt;80/tcp web065a1d7105ef29 0901fa9da894 &quot;/docker-entrypoint.…&quot; 21 minutes ago Up 21 minutes 127.0.0.1:32770-&gt;80/tcp web046cdfd996b45c 0901fa9da894 &quot;/docker-entrypoint.…&quot; 28 minutes ago Up 28 minutes 0.0.0.0:32769-&gt;80/tcp web033f1cbb448709 0901fa9da894 &quot;/docker-entrypoint.…&quot; 44 minutes ago Up 44 minutes 0.0.0.0:32768-&gt;80/tcp web01[root@docker ~]# docker container top 95b7279dbe9d # 查看指定容器内的进程UID PID PPID C STIME TTY TIME CMDroot 21685 21667 0 18:01 ? 00:00:00 nginx: master process nginx -g daemon off;101 21739 21685 0 18:01 ? 00:00:00 nginx: worker process# 查看容器运行日志[root@docker ~]# docker container logs --help Usage: docker container logs [OPTIONS] CONTAINERFetch the logs of a containerOptions: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default &quot;all&quot;) -t, --timestamps Show timestamps # 显示时间 --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)# 查看指定容器的日志信息[root@docker ~]# docker container logs 95b7279dbe9d/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d//docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh10-listen-on-ipv6-by-default.sh: Getting the checksum of /etc/nginx/conf.d/default.conf10-listen-on-ipv6-by-default.sh: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh/docker-entrypoint.sh: Configuration complete; ready for start up10.138.3.1 - - [17/Jul/2020:10:01:50 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &quot;-&quot;2020/07/17 10:01:50 [error] 28#28: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 10.138.3.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;10.138.3.15:9999&quot;, referrer: &quot;http://10.138.3.15:9999/&quot;10.138.3.1 - - [17/Jul/2020:10:01:50 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 555 &quot;http://10.138.3.15:9999/&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &quot;-&quot;# 查看指定容器的最近5条日志信息[root@docker ~]# docker container logs -tf --tail 5 95b7279dbe9d# -t 显示日志时间； -f ；--tail 动态显示日志2020-07-17T10:01:05.405618181Z /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh2020-07-17T10:01:05.407662304Z /docker-entrypoint.sh: Configuration complete; ready for start up2020-07-17T10:01:50.787156188Z 10.138.3.1 - - [17/Jul/2020:10:01:50 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &quot;-&quot;2020-07-17T10:01:50.885303440Z 2020/07/17 10:01:50 [error] 28#28: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 10.138.3.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;10.138.3.15:9999&quot;, referrer: &quot;http://10.138.3.15:9999/&quot;2020-07-17T10:01:50.885398127Z 10.138.3.1 - - [17/Jul/2020:10:01:50 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 555 &quot;http://10.138.3.15:9999/&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&quot; &quot;-&quot; 五. docker容器存储​ 将数据从宿主机挂载到容器中的三种方式： volumes：Docker管理宿主机文件系统的一部分(/var/lib/docker/volumes)，保存数据的最佳方法 bind mounts：将宿主机上的任意位置的文件或者目录挂载到容器中。 tmpfs：挂载存储在主机系统的内存中，而不会写入主机的文件系统。如果不希望将数据持久化存储在任何位置，可以使用tmpfs，同时避免写入容器可写层提高性能。 添加–5.1 volumes：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# docker volume lsDRIVER VOLUME NAME# # docker volume --helpUsage: docker volume COMMANDManage volumesCommands: create Create a volume # 新建卷 inspect Display detailed information on one or more volumes # 查看卷信息 ls List volumes # 列出当前系统上的容器卷 prune Remove all unused local volumes # 移除所有未使用的本地卷 rm Remove one or more volumes # 删除卷Run &#x27;docker volume COMMAND --help&#x27; for more information on a command.# docker volume create nginx-volnginx-vol# docker volume lsDRIVER VOLUME NAMElocal nginx-vol# docker volume inspect nginx-vol[ &#123; &quot;CreatedAt&quot;: &quot;2021-04-01T16:01:18+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nginx-vol/_data&quot;, # 挂载点 &quot;Name&quot;: &quot;nginx-vol&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;]# ll /var/lib/docker/volumes/total 24brw------- 1 root root 253, 0 Apr 1 10:59 backingFsBlockDev-rw------- 1 root root 32768 Apr 1 15:49 metadata.db drwx-----x 3 root root 19 Apr 1 15:49 nginx-vol # 刚刚新建的容器卷# 新建容器并挂载容器挂# docker run -d --name nginx-web01 --mount src=nginx-vol,dst=/usr/share/nginx/html nginx5b001e1b7aa012f677b733bba3186cee072b89d0f2845e3dbdc99c46e93b6674## 上面的写法也可以使用-v，如下# docker run -d --name nginx-web01 -v nginx-vol:/usr/share/nginx/html nginx# ls /var/lib/docker/volumes/nginx-vol/_data/50x.html index.html # 使用volume后，把nginx根目录中的文件保留了下来# docker exec -it nginx-web01 bash # 进入到容器中查看nginx的根目录root@5b001e1b7aa0:/# ls /usr/share/nginx/html/50x.html index.html# 在容器中nginx根目录或者容器卷中新建文件/目录，容器内和宿主机上的容器卷都是一样的显示内容root@5b001e1b7aa0:/usr/share/nginx/html# echo `date` &gt; date.html # 在容器内新建文件root@5b001e1b7aa0:/usr/share/nginx/html# cat date.html Thu Apr 1 07:58:05 UTC 2021# curl 172.17.0.4/date.html # 在宿主机上访问date.html文件Thu Apr 1 07:58:05 UTC 2021# 查看宿主机上的容器卷目录# ls /var/lib/docker/volumes/nginx-vol/_data/50x.html date.html index.html# 在宿主机容器卷nginx-vol内新建文件，查看容器内nginx根目录的变化# mkdir /var/lib/docker/volumes/nginx-vol/_data/data# ls /var/lib/docker/volumes/nginx-vol/_data/50x.html data date.html index.html# 容器内nginx根目录显示内容：root@5b001e1b7aa0:/usr/share/nginx/html# ls 50x.html data date.html index.html# 我们在不创建容器卷，直接使用-v选项时，默认自动创建容器卷，如下# docker run -d --name nginx-web02 -v nginx-vol2:/usr/share/nginx/html nginx50b894e5d6889fcc276f1f200491365b0dc9f7a0e865cd8616c1759436e2dfce# ls /var/lib/docker/volumes/backingFsBlockDev metadata.db nginx-vol/ nginx-vol2/ # ls /var/lib/docker/volumes/nginx-vol2/_data# docker volume ls DRIVER VOLUME NAMElocal nginx-vollocal nginx-vol2# 此时删除容器，容器卷中的数据依旧存在，并且将该容器卷挂载给下一个新建的容器，也没有问题 添加–5.2 bind mounts：​ 将宿主机上的任一个目录挂载到容器中，若该目录不存在，将自动新建，会覆盖掉容器内的指定目录 12345678910111213141516# ls /data_docker/share# docker run -d --name nginx-web03 -v /data_docker/wwwroot/:/usr/share/nginx/html nginx8d3cc664a13e87b6da052f2812ac0fe471e3e7c77959e1bc74eb3d916a3153e5 # 宿主机的路径必须是绝对路径# ls /data_docker/share wwwroot# ls /data_docker/wwwroot/# #使用bind mounts后，宿主机目录将容器内目录覆盖掉了# docker volume ls # 容器卷不包含bind mounts挂载的目录DRIVER VOLUME NAMElocal nginx-vollocal nginx-vol2 12345678910111213141516171819202122232425262728# 批量停止并删除宿主机上容器[root@docker ~]# docker container stop `docker container ls -a -q`[root@docker ~]# docker container rm `docker container ls -a -q`# 启动一个对外访问的nginx服务[root@docker ~]# docker run -d -p 10.138.3.15:80:80 --name web01 0901fa9da894b203bce1e8cf658e50207fe143a27a5b8992c2c02961386fc58529a73d1f51c2[root@docker ~]# docker exec -it web01 /bin/bash # 进入容器root@b203bce1e8cf:/# cd /usr/share/nginx/html/root@b203bce1e8cf:/usr/share/nginx/html# ls 50x.html index.htmlroot@b203bce1e8cf:/usr/share/nginx/html# vim index.html # 没有安装vim命令bash: vim: command not foundroot@b203bce1e8cf:/usr/share/nginx/html# vi index.html # 没有安装vi命令bash: vi: command not foundroot@b203bce1e8cf:/usr/share/nginx/html# echo &quot;hello nginx&quot; &gt; index.htmlroot@b203bce1e8cf:/usr/share/nginx/html# cat index.html hello nginxroot@b203bce1e8cf:/usr/share/nginx/html# cat /etc/issue # 是debian的系统Debian GNU/Linux 10 \\n \\lroot@b203bce1e8cf:/usr/share/nginx/html# apt-get install vim # 未配置源安装vim出错Reading package lists... DoneBuilding dependency tree Reading state information... DoneE: Unable to locate package vim ​ 由于容器只是一个最小化的程序运行环境，因此，我们要想登录到容器内进行管理，是一件很麻烦的的事儿，而且 5.1 手工数据交互如何手动实现宿主机与容器进行数据交互 将容器中的文件拷贝到宿主机中：docker container cp container_name:container_Path host_Path 将宿主机文件拷贝到容器中：docker container cp host_Path container_name:container_Path tips：该方法只使用于量小的文件拷贝 docker container cp的用法 123456789101112131415[root@docker ~]# docker container cp --helpUsage: docker container cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATHCopy files/folders between a container and the local filesystemUse &#x27;-&#x27; as the source to read a tar archive from stdinand extract it to a directory destination in a container.Use &#x27;-&#x27; as the destination to stream a tar archive of acontainer source to stdout.Options: -a, --archive Archive mode (copy all uid/gid information) -L, --follow-link Always follow symbol link in SRC_PATH 将宿主机上的文件拷贝到容器中： 12[root@docker ~]# echo &quot;today is `date +%F`&quot; &gt; date.html[root@docker ~]# docker container cp ./date.html web01:/usr/share/nginx/html/ 通过浏览器访问，结果如下： 将nginx容器中的文件拷贝到宿主机： 123[root@docker ~]# docker container cp web01:/usr/share/nginx/html/index.html .[root@docker ~]# cat index.html hello nginx 5.2 持久卷–volume​ 在容器的生命周期中，当用户删除容器后，容器中的数据也被删除，这样就造成了数据的丢失，那么如果将容器中的数据进行持久化存储呢？docker引入了volume的概念。 -v： 格式为-v 宿主机目录:容器目录 12345678910111213141516171819202122232425262728# 提前准备好nginx将要使用的根目录[root@docker html]# tree ../html/../html/├── date.html└── index.html0 directories, 2 files[root@docker html]# cat date.html index.html today is 2020-07-18welcome to nginx# 启动容器，如果容器中原本没有映射的目录，在启动容器时，将自动创建映射目录[root@docker html]# docker run -d --name web02 -p 8080:80 -v /root/html:/usr/share/nginx/html 0901fa9da894204f493ce2cc29df1d86c408a4cfd5f797cc33f0861da2e0b7f586f9d1deda96[root@docker html]# docker ps # 检查启动状态CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES204f493ce2cc 0901fa9da894 &quot;/docker-entrypoint.…&quot; 17 seconds ago Up 16 seconds 0.0.0.0:8080-&gt;80/tcp web02b203bce1e8cf 0901fa9da894 &quot;/docker-entrypoint.…&quot; 21 hours ago Up 18 minutes 10.138.3.15:80-&gt;80/tcp web01# 进入容器进行查看映射目录[root@docker html]# docker exec -it 204f493ce2cc /bin/bashroot@204f493ce2cc:/# ls /usr/share/nginx/html/date.html index.htmlroot@204f493ce2cc:/# cat /usr/share/nginx/html/date.html today is 2020-07-18root@204f493ce2cc:/# cat /usr/share/nginx/html/index.html welcome to nginx 通过浏览器访问： ​ 此时，我们就可以在宿主机上修改nginx根目录中的文件内容，从而不再需要登录到容器内，即使在容器销毁后，宿主机中的nginx根目录也存在，从而达到了数据的持久性存储。 查看主机与容器卷的映射关系 123456789101112[root@docker html]# docker container inspect 204f493ce2cc···&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/root/html&quot;, &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125;···· ​ 我们可以通过启动多个容器，映射同一个目录，从而实现nginx的高可用 12[root@docker html]# docker run -d --name web03 -p 8000:80 -v /root/html:/usr/share/nginx/html 0901fa9da8942e5eeb728f82e138ba7fc638e1f168f6dfa2200a3d83f14e34c96edaf2eb8069 ​ 上面我们启动了两个nginx容器，这两个nginx容器都将宿主机上的目录(等同于共享存储)与nginx容器的nginx服务根目录做了映射，因此我们访问两个nginx容器将得到相同的内容。 5.3 数据卷容器​ 通过5.2章节，我们知道，我们可以通过-v参数进行容器与主机磁盘的映射，那么如果有成百上千个容器都需要挂载，那么手动使用-v参数进行挂载将是一件可怕的事情。 ​ 在集中化管理集群中，大批量的容器都需要挂载相通的多个数据卷时，可以使用数据卷容器进行统一挂载和管理。 1234567891011121314151617181920212223242526272829# 宿主机模拟数据目录[root@docker ~]# tree /opt/Volume//opt/Volume/├── a│?? └── a.txt└── b └── b.txt2 directories, 2 files[root@docker ~]# cat /opt/Volume/a/a.txt /opt/Volume/b/b.txt a # /opt/Volume/a/a.txt中的内容b # /opt/Volume/b/b.txt中的内容# 创建并启动数据卷容器[root@docker ~]# docker run -it --name nginx_volumes -v /opt/Volume/a:/opt/a -v /opt/Volume/b:/opt/b f1cb7c7d58b7 /bin/bash [root@26d2c849bc9b /]# ls /opt/a/a.txt[root@26d2c849bc9b /]# ls /opt/b/b.txt# ctrl + p,q退出终端，以达到容器不停止# 其他容器使用数据卷容器[root@docker ~]# docker run -d -p 8001:80 --volumes-from nginx_volumes --name web04 0901fa9da8940e7af67dafde5175aa4c0492e1e28f47e90c311ffffd11cd45adcb9763c139a8[root@docker ~]# docker run -d -p 8002:80 --volumes-from nginx_volumes --name web05 0901fa9da894608d643b5142c0a49314ec8d0a67e00ee8d4f2974b005fd5af8b5ea63b2a8169# 上述中，即使nginx_volumes容器挂掉，也不会影响引用nginx_volumes容器卷的容器web04和web05 验证： 通过docker exec登录到容器内进行检查 通过docker container inspect查看容器详细信息进行检查 1234567891011121314151617181920[root@docker ~]# docker container inspect web04···&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/opt/Volume/a&quot;, &quot;Destination&quot;: &quot;/opt/a&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125;, &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/opt/Volume/b&quot;, &quot;Destination&quot;: &quot;/opt/b&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125;··· ​ 这样的好处是，即使数据卷容器宕掉后，也不影响使用数据卷的其他容器。 案例：停止数据卷容器，查看web04和web05中是否还存在挂载的目录文件 123456789[root@docker ~]# docker container stop nginx_volumes nginx_volumes # 停止数据卷容器[root@docker ~]# docker exec -it web04 /bin/bash # 进入web04容器root@0e7af67dafde:/# ls /opt/ # 该容器中仍然存在数据卷容器挂载的目录a broot@0e7af67dafde:/# ls /opt/a/a.txt /opt/a/a.txtroot@0e7af67dafde:/# ls /opt/b/b.txt /opt/b/b.txt tips：数据卷容器简化了容器目录映射的方式，即使数据卷容器宕机，也不影响其他容器对挂载文件的使用。 六. 自制docker镜像和docker仓库进阶6.1准备工作：制作本地局域网yum源 安装并启动vsftpd 12[root@docker ~]# yum -y install vsftpd[root@docker ~]# systemctl enable vsftpd &amp;&amp; systemctl start vsftpd 上传镜像到虚拟机 12[root@docker ~]# ls /mnt/iso/CentOS-6.10-x86_64-bin-DVD1.iso CentOS-7.6-x86_64-DVD-1810.iso 配置yum仓库 123456789101112131415161718192021222324# 创建ftp镜像挂载目录[root@docker ~]# mkdir -p /var/ftp/centos7.6[root@docker ~]# mkdir -p /var/ftp/centos6.10# 挂载光盘文件到ftp镜像挂载目录[root@docker ~]# mount -o loop /mnt/iso/CentOS-6.10-x86_64-bin-DVD1.iso /var/ftp/centos6.10/mount -o loop /mnt/iso/CentOS-7.6-x86_64-DVD-1810.iso [root@docker ~]# /var/ftp/centos7.6/[root@docker ~]# cat &gt; /etc/yum.repos.d/ftp6.repo &lt;&lt; EOF[ftp6_10]name=ftp6_10baseurl=ftp://10.138.3.15/centos6.10enabled=1gpgcheck=0EOF# 注意，如果用上述IP地址访问不到，就用docker0的地址，默认是172.17.0.1[root@docker ~]# cat &gt; /etc/yum.repos.d/ftp7.repo &lt;&lt; EOF[ftp7.6]name=ftp7.6baseurl=ftp://10.138.3.15/centos7.6enabled=1gpgcheck=0EOF 浏览器访问如下所示： 6.2 docker镜像进阶Docker镜像含有启动容器所需要的文件系统及其内容，因此，其用于创建并启动docker容器。 Docker镜像采用分层构建机制，最底层是bootfs（引导文件系统）、其次是tootfs（用户文件系统）： bootfs用于系统引导的文件系统，包括boot loader和kernel，容器启动完成后会卸载以节约内存空间； rootfs位于bootfs之上，表现为docker容器的根文件系统：传统模式中，系统启动之时，内核挂载rootfs时会首先将其挂载为“只读”模式，完整性自检完成后将其重新挂载为读写模式（Linux系统启动模式）；docker中，rootfs由内核挂载为“只读”模式，而后通过“联合挂载”技术额外挂载一个“可写”层； 下图中，位于下层的镜像为父镜像（parent image），最底层成为基础镜像（base image），最上层我“可读写”层，其下的均为“只读”层。 ​ Aufs（advanced multi-layered unification filesystem）：高级多层联合文件系统 ​ 用于Linux文件系统实现“联合挂载”，docker最初使用aufs作为容器文件系统层，它目前仍作为存储后端之一来支持；aufs的竞争产品overlayfs，后者自从3.18版本开始被合并到Linux内核，docker的分层镜像，除了aufs，还支持btrfs，devicemapper(dm)和vfs等（在Ubuntu系统中，aufs合并到了Ubuntu系统中；但CentOS系统未合并，因此使用aufs系统需打补丁，CentOS默认使用的是overlayfs） 6.2.1 基于容器制作镜像：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 删除之前的docker容器[root@docker ~]# docker container stop `docker container ls -a -q`[root@docker ~]# docker container rm `docker container ls -a -q`[root@docker ~]# docker image ls | grep centoscentos centos6.10 48650444e419 16 months ago 194MBcentos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MB# 启动容器[root@docker ~]# docker run -it -d --name centos6.10 48650444e419 /bin/bash625565a2013b5ec622764991d24161e45d580287e58397463c54801a26377483[root@docker ~]# docker run -it -d --name centos7.6 f1cb7c7d58b7 /bin/bash9d064f7416ec58a303df244018588d936942460ab55bc50ada9f4a70b9869e7d# 分别进入centos7.6和centos6.10容器配置各自版本的yum源# 将6的yum源配置到centos6.10容器中[root@625565a2013b /]# cat &gt; /etc/yum.repos.d/ftp6.repo &lt;&lt; EOF&gt; [ftp6_10]&gt; name=ftp6_10&gt; baseurl=ftp://172.17.0.1/centos6.10&gt; enabled=1&gt; gpgcheck=0&gt; EOF# 将7的yum源配置到centos7.6容器中[root@9d064f7416ec /]# cat &gt; /etc/yum.repos.d/ftp7.repo &lt;&lt; EOF&gt; [ftp7.6]&gt; name=ftp7.6&gt; baseurl=ftp://172.17.0.1/centos7.6&gt; enabled=1&gt; gpgcheck=0&gt; EOF[root@9d064f7416ec /]# yum clean all &amp;&amp; yum repolist···repo id repo name statusbase/7/x86_64 CentOS-7 - Base 10070extras/7/x86_64 CentOS-7 - Extras 412ftp7.6 ftp7.6 4021updates/7/x86_64 CentOS-7 - Updates 900repolist: 22116# 安装ssh服务并启动，以便通过ssh服务进行登录容器[root@9d064f7416ec /]# yum -y install openssh* net-tools[root@9d064f7416ec ~]# ifconfig | grep 172.17 inet 172.17.0.3 netmask 255.255.0.0 broadcast 172.17.255.255[root@9d064f7416ec ~]# echo &quot;root:123456&quot; | chpasswd [root@9d064f7416ec ~]# systemctl start sshd[root@9d064f7416ec ~]# systemctl enable sshd[root@625565a2013b /]# yum -y install openssh* net-tools[root@625565a2013b ~]# echo &quot;root:123456&quot; | chpasswd [root@625565a2013b ~]# ifconfig | grep 172.17 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0[root@625565a2013b ~]# service sshd startGenerating SSH2 RSA host key: [ OK ] # 生成了某些文件Generating SSH1 RSA host key: [ OK ] # 生成了某些文件Generating SSH2 DSA host key: [ OK ] # 生成了某些文件Starting sshd: [ OK ][root@625565a2013b ~]# chkconfig --add sshd# 这里我们配置本地yum源的目的只是为了展示本地yum源的配置方法，而且一般情况下，公司使用的都是内网环境，因此配置本地yum源是必须的。 ​ 上面的容器就是再原有容器的基础上，添加了ssh服务，因此我们可以将该容器进行保存为镜像，以便后期使用，而不是每次都进行指定软件包的安装。 123456789101112131415161718192021222324252627[root@docker ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9d064f7416ec f1cb7c7d58b7 &quot;/bin/bash&quot; 54 minutes ago Up 38 minutes centos7.6625565a2013b 48650444e419 &quot;/bin/bash&quot; 55 minutes ago Up 42 minutes centos6.10[root@docker ~]# docker commit --help # docker commit的用法Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Create a new image from a container&#x27;s changesOptions: -a, --author string Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;) -c, --change list Apply Dockerfile instruction to the created image -m, --message string Commit message -p, --pause Pause container during commit (default true)[root@docker ~]# docker commit centos7.6 scaven:cnetos7.6sha256:0668a0538f149667fcaab1950f942bfbbdfd57db01b7674c2b4e3b0a11c0c291[root@docker ~]# docker commit centos6.10 scaven:cnetos6.10sha256:f1b33ecfb10763152ed80217b3a729b505983fecda4d22c19163c0a6bd2a9eb3[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEscaven cnetos6.10 f1b33ecfb107 7 seconds ago 485MBscaven cnetos7.6 0668a0538f14 20 seconds ago 424MBscaven/nginx 1.2 0901fa9da894 8 days ago 132MBcentos centos6.10 48650444e419 16 months ago 194MBcentos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MBubuntu 15.10 9b9cb95443b5 3 years ago 137MB ​ 此时我们可以通过保存下来的镜像(保存了容器中的各种文件)，启动容器，但是值得注意的是，启动该容器并不会有启动ssh服务(保存了容器中的各种文件，ssh服务的启动并没有在容器的文件中，因为我们是在命令行启动的ssh服务)，因为我们保存镜像时，保存的是当前的文件系统，并不能保存容器中的进程，因此，ssh服务是没有启动的，要么我们手动指定启动ssh服务(进入容器内启动或启动容器时在命令行指定)，要么我们将ssh添加到容器启动时的默认执行命令。 进入容器内启动 12345678910111213141516[root@docker ~]# docker run -it -d --name centos6_sshd f1b33ecfb107 /bin/bash d6f755ad89cfaadae10fd92cd2ee1aaedebee00fd79c6b6673bf03ddc80e9428[root@docker ~]# docker exec -it d6f755ad89cf /bin/bash[root@d6f755ad89cf /]# netstat -lntpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name [root@d6f755ad89cf /]# service sshd startStarting sshd: [ OK ][root@d6f755ad89cf /]# netstat -lntpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 49/sshd tcp 0 0 :::22 :::* LISTEN 49/sshd # ctrl p,q 退出 启动容器时命令行指定启动 123456789101112131415[root@docker ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6f755ad89cf f1b33ecfb107 &quot;/bin/bash&quot; 7 minutes ago Up 7 minutes centos6_sshd9d064f7416ec f1cb7c7d58b7 &quot;/bin/bash&quot; About an hour ago Up About an hour centos7.6625565a2013b 48650444e419 &quot;/bin/bash&quot; About an hour ago Up About an hour centos6.10[root@docker ~]# docker run -it -d --name centos6_ssh f1b33ecfb107 service sshd starta2a0ce8779e6724aeb861c5b667799c66e7e4cdf85c0ebed8eeebb77057ff3bf[root@docker ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6f755ad89cf f1b33ecfb107 &quot;/bin/bash&quot; 7 minutes ago Up 7 minutes centos6_sshd9d064f7416ec f1cb7c7d58b7 &quot;/bin/bash&quot; About an hour ago Up About an hour centos7.6625565a2013b 48650444e419 &quot;/bin/bash&quot; About an hour ago Up About an hour centos6.10 ​ 从上我们可以看出，容器执行完service sshd start命令后就直接停止运行了(执行命令service sshd start的窗口退出，容器就停止运行)，那么我们是否可以将ssh服务放在前台启动，即启动ssh服务的窗口永远不关闭 1234567891011# 使用/usr/sbin/sshd -D命令可以将ssh服务前台启动，即窗口一直不退出，夯在前台，因此容器也不会执行完命令就退出[root@docker ~]# docker run -it -d --name centos6_ssh_d f1b33ecfb107 /usr/sbin/sshd -D38990dc22fec4efd91d477f08869c7f87681663ee668b68394fc58860ecc5ecd# 加上-p 22参数就能暴露端口，实现宿主机之外的网络访问[root@docker ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES38990dc22fec f1b33ecfb107 &quot;/usr/sbin/sshd -D&quot; 6 seconds ago Up 5 seconds centos6_ssh_dd6f755ad89cf f1b33ecfb107 &quot;/bin/bash&quot; 13 minutes ago Up 13 minutes centos6_sshd9d064f7416ec f1cb7c7d58b7 &quot;/bin/bash&quot; About an hour ago Up About an hour centos7.6625565a2013b 48650444e419 &quot;/bin/bash&quot; About an hour ago Up About an hour centos6.10 将ssh服务加入容器启动时的第一命令中 6.2.2 构建企业网站定制镜像–BBS6.2.2.1 第一版镜像的制作–lamp环境123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# 新建目录存放MySQL和web网页目录，以便做持久化存储[root@docker ~]# mkdir -p /opt/Volume/bbs/mysql /opt/Volume/bbs/html# 启动容器[root@docker ~]# docker run -it -d --name centos6_bbs -v /opt/Volume/bbs/mysql/:/var/lib/mysql -v /opt/Volume/bbs/html/:/var/www/html 48650444e419b8d9eb05d4ed43a192a850c0c0792d1e0b0cb1c0d95c3d084f1785fd2e5ac0a3# 配置yum源[root@b8d9eb05d4ed /]# cat &gt; /etc/yum.repos.d/ftp6.repo &lt;&lt; EOF&gt; [ftp6_10]&gt; name=ftp6_10&gt; baseurl=ftp://172.17.0.1/centos6.10&gt; enabled=1&gt; gpgcheck=0&gt; EOF[root@b8d9eb05d4ed /]# yum clean all &amp;&amp; yum repolist# 安装lamp[root@b8d9eb05d4ed /]# yum -y install openssh* httpd mysql php php-mysql mysql-server# 软件初始化## ssh服务初始化[root@b8d9eb05d4ed /]# /etc/init.d/sshd startGenerating SSH2 RSA host key: [ OK ]Generating SSH1 RSA host key: [ OK ]Generating SSH2 DSA host key: [ OK ]Starting sshd: [ OK ][root@b8d9eb05d4ed /]# echo &quot;root:123456&quot; | chpasswd ## mysql初始化[root@b8d9eb05d4ed /]# /etc/init.d/mysqld startInitializing MySQL database: Installing MySQL system tables...OKFilling help tables...OK···Please report any problems with the /usr/bin/mysqlbug script! [ OK ]Starting mysqld: [ OK ][root@b8d9eb05d4ed /]# cd /var/lib/mysql/[root@b8d9eb05d4ed mysql]# ll total 20484-rw-rw---- 1 mysql mysql 5242880 Jul 19 14:59 ib_logfile0-rw-rw---- 1 mysql mysql 5242880 Jul 19 14:59 ib_logfile1-rw-rw---- 1 mysql mysql 10485760 Jul 19 14:59 ibdata1drwx------ 2 mysql mysql 4096 Jul 19 14:59 mysqlsrwxrwxrwx 1 mysql mysql 0 Jul 19 14:59 mysql.sockdrwx------ 2 mysql mysql 6 Jul 19 14:59 test[root@b8d9eb05d4ed mysql]# mysql # 启动mysql# 新建数据库、用户和授权mysql&gt; grant all on *.* to root@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; grant all on *.* to discuz@&#x27;%&#x27; identified by &#x27;123456&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; grant all on *.* to discuz@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; create database discuz charset utf8; Query OK, 1 row affected (0.00 sec)# 检查宿主机上文件持久化存储结果[root@docker ~]# ls /opt/Volume/bbs/mysql/ibdata1 ib_logfile0 ib_logfile1 mysql mysql.sock test# 初始化http服务[root@b8d9eb05d4ed mysql]# /etc/init.d/httpd startStarting httpd: httpd: Could not reliably determine the server&#x27;s fully qualified domain name, using 172.17.0.6 for ServerName [ OK ]# 通过宿主机访问，结果正常[root@docker ~]# curl -I 172.17.0.6HTTP/1.1 403 ForbiddenDate: Sun, 19 Jul 2020 15:09:08 GMTServer: Apache/2.2.15 (CentOS)Accept-Ranges: bytesContent-Length: 4961Connection: closeContent-Type: text/html; charset=UTF-8# 制作lamp第一版基础镜像[root@docker ~]# docker commit b8d9eb05d4ed centos6_lamp:v1sha256:f022bb774837bd1f28646ca0222005e6962e98a39f7d7ce50ffedd5dbb82a758[root@docker ~]# docker image ls # grep lampREPOSITORY TAG IMAGE ID CREATED SIZEcentos6_lamp v1 f022bb774837 6 seconds ago 476MB# 停止第一版容器[root@docker ~]# docker container stop centos6_bbs# 使用lamp第一版镜像启动容器，并暴露80端口[root@docker ~]# docker run -it --name centos6_lamp -p 8080:80 -v /opt/Volume/bbs/mysql/:/var/lib/mysql -v /opt/Volume/bbs/html/:/var/www/html f022bb774837# 启动MySQL和阿帕奇服务[root@e6551f8c73eb /]# /etc/init.d/mysqld startStarting mysqld: [ OK ][root@e6551f8c73eb /]# /etc/init.d/httpd startStarting httpd: httpd: Could not reliably determine the server&#x27;s fully qualified domain name, using 172.17.0.6 for ServerName [ OK ]# 编辑简单的php页面php和http访问情况[root@docker ~]# cat /opt/Volume/bbs/html/index.php # 在宿主机上编写即可&lt;?php phpinfo();?&gt; ​ 此时，可通过浏览器测试php的访问状态： 6.2.2.2 第二版镜像的制作–安装bbs123456789101112131415161718# 下载bbs软件包[root@docker ~]# git clone https://gitee.com/ComsenzDiscuz/DiscuzX.gitCloning into &#x27;DiscuzX&#x27;...remote: Enumerating objects: 3493, done.remote: Counting objects: 100% (3493/3493), done.remote: Compressing objects: 100% (905/905), done.remote: Total 11627 (delta 2935), reused 2670 (delta 2588), pack-reused 8134Receiving objects: 100% (11627/11627), 14.85 MiB | 5.71 MiB/s, done.Resolving deltas: 100% (5734/5734), done.[root@docker ~]# cd DiscuzX/[root@docker DiscuzX]# ls readme README.md upload utility# 将upload目录下的所有文件拷贝到http服务根目录下，并给与777的权限[root@docker DiscuzX]# cp -r upload/* /opt/Volume/bbs/html/cp: overwrite ‘/opt/Volume/bbs/html/index.php’? yes[root@docker DiscuzX]# chmod -R 777 /opt/Volume/bbs/html/ 接下来就是页面化操作了 检查状态是否符合要求 设置运行环境 安装数据库，设置数据库信息 安装完成，点击右下角进入论坛 进入论坛，结果正常 保存第二版镜像 123456789[root@docker ~]# docker commit -m &quot;welcom to bbs&quot; e6551f8c73eb scaven/centos6_bbs:v1sha256:5259a77d042b9f0a2ca73f385603733d025b22c1ce3e549e1c25f95cd7c8bdcb[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEscaven/centos6_bbs v1 5259a77d042b 10 seconds ago 477MB# 停止容器[root@docker ~]# docker container stop e6551f8c73eb 6.2.2.3 第三版镜像的制作–创建启动脚本​ docker容器只能启动时只能指定启动一个进程，那么，我们可以编写一个启动脚本，只要把需要启动的访问，放在该脚本中，并最后保持运行该脚本的窗口不退出即可。 12345678910[root@docker ~]# cat /opt/Volume/bbs/html/init.sh#!/bin/bash/etc/init.d/mysqld start # 启动MySQL/etc/init.d/httpd start # 启动http/usr/sbin/sshd -D # 启动ssh，该命令是前端运行，即端口不退出[root@docker ~]# chmod +x /opt/Volume/bbs/html/init.sh# 基于第二版镜像，启动容器，暴露http端口，MySQL端口，ssh端口，并执行上面创建的脚本[root@docker ~]# docker run -d --name centos6_bbs_v1 -p 8000:80 -p 2222:22 -p 13306:3306 -v /opt/Volume/bbs/mysql/:/var/lib/mysql -v /opt/Volume/bbs/html/:/var/www/html 5259a77d042b /var/www/html/init.sh97bf03282d31439ed03201e95aaba52443c86718fc9f5fd0772b2884c00af7c3 检查验证–ssh服务 宿主机连接ssh服务，通过ip地址直接连接就可以，不需要使用端口 1234[root@docker ~]# ssh 172.17.0.6root@172.17.0.6&#x27;s password: # 123456 Last login: Sun Jul 19 16:12:52 2020 from 10.138.3.1[root@97bf03282d31 ~] # 外部网络通过xshell连接容器 检查验证–bbs论坛 检查验证–mysql服务 6.2.3 制作centos7的sshd服务镜像123456789101112131415161718192021222324252627282930313233343536373839# 启动centos7.6基础镜像[root@docker ~]# docker run -it --name centos7_sshd f1cb7c7d58b7[root@d4b3c4402094 /]# yum -y install openssh*[root@d4b3c4402094 /]# systemctl start sshd # 使用该命令启动不了ssh服务Failed to get D-Bus connection: Operation not permitted[root@d4b3c4402094 /]# /etc/init.d/sshd start # 该脚本启动也有很多命令没有/etc/init.d/sshd: line 30: /etc/rc.d/init.d/functions: No such file or directory/usr/sbin/sshd-keygen: line 10: /etc/rc.d/init.d/functions: No such file or directoryGenerating SSH2 RSA host key: /usr/sbin/sshd-keygen: line 63: success: command not foundGenerating SSH2 ECDSA host key: /usr/sbin/sshd-keygen: line 105: success: command not foundGenerating SSH2 ED25519 host key: /usr/sbin/sshd-keygen: line 126: success: command not foundStarting sshd: /etc/init.d/sshd: line 64: success: command not found/etc/init.d/sshd: line 64: failure: command not found# 手动初始化sshd服务[root@d4b3c4402094 /]# mkdir /var/run/sshd[root@d4b3c4402094 /]# echo &#x27;UseDNS no&#x27; &gt;&gt; /etc/ssh/sshd_config[root@d4b3c4402094 /]# sed -i -e &#x27;/pam_loginuid.so/d&#x27; /etc/pam.d/sshd[root@d4b3c4402094 /]# echo &#x27;root:123456&#x27; | chpasswd[root@d4b3c4402094 /]# /usr/bin/ssh-keygen -A # 初始化成功ssh-keygen: generating new host keys: RSA1 DSA # 保存含有ssh服务的镜像[root@docker ~]# docker container ls |grep centos7_sshdCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd4b3c4402094 f1cb7c7d58b7 &quot;/bin/bash&quot; 7 minutes ago Up 7 minutes centos7_sshd[root@docker ~]# docker commit -m &quot;centos7 add sshd&quot; d4b3c4402094 scaven/centos:sshd_v1sha256:40b6e896f747f9ea5757ff36f1803e1d8e7a16189a53838b2258e36ff0da3ce4# 启动含有ssh服务的镜像[root@docker ~]# docker run -d --name testsshd -p 222:22 40b6e896f747 /usr/sbin/sshd -D03a9e7608154a856877fa13479b0dace6eb8c02bc14a3a2654e4a5c62d72c18f 通过xshell连接 6.3 通过dockerfile制作docker镜像6.3.1 制作ssh服务的centos7镜像格式： FROM–指定该镜像基于的基础镜像 格式1：FROM centos:centos6.10 指定从那个仓库中的那个镜像，不建议使用，tag是很容易进行人为修改的，因此不安全 格式2： FROM centos@镜像id 建议使用该种方法 RUN–指定需要运行的命令 格式1：常规shell命令–RUN +shell命令，值得注意的是，命令必须存在 格式2：非shell命令–RUN [“命令”,”参数或选项1”,”参数或选项2”,”····”]，如 RUN [&quot;mysqld&quot;,&quot;--datadir=xx&quot;,&quot;--basedir=xx&quot;,&quot;--user=mysql&quot;] CMD–容器启动时执行的命令，一般是需要能夯住在前端的，不退出窗口的命令 格式：CMD [“命令”,”参数或选项1”,”参数或选项2”,”····”] EXPOSE–指定该容器暴露的端口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 删除上面实验的所有容器[root@docker ~]# docker container rm -f `docker container ls -a -q`[root@docker ~]# mkdir -p /data/dockerfile # 创建制作镜像目录# 开始制作镜像[root@docker dockerfile]# vim Dockerfile # 新建该文件，名称可以是小写# 备注信息：Centos6.10_SSHDv1.0# 1 设置基础镜像，建议使用下面的写法，而不是使用tag标签FROM centos:centos6.10# 2 添加制作镜像的相关命令，建议多个命令一起写，不然层级太多RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e &quot;[ftp6]\\nname=ftp6\\nbaseurl=ftp://172.17.0.1/centos6.10\\nenabled=1\\ngpgcheck=0&quot; &gt; /etc/yum.repos.d/ftp6.repo &amp;&amp; yum clean all &amp;&amp; yum repolist &amp;&amp; yum -y install openssh-server RUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/stop &amp;&amp; echo &quot;root:123456&quot; | chpasswd# 3 容器启动时指定的命令CMD [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]# 4 暴露端口EXPOSE 22# 制作镜像，默认就会使用当前目录中的Dockerfile文件[root@docker dockerfile]# docker image build -t &quot;centos6_10_add_sshd&quot; ./Sending build context to Docker daemon 2.56kBStep 1/5 : FROM centos:centos6.10 # 第一步完成后生成的镜像 ---&gt; 48650444e419Step 2/5 : RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e &quot;[ftp6]\\nname=ftp6\\nbaseurl=ftp://172.17.0.1/centos6.10\\nenabled=1\\ngpgcheck=0&quot; &gt; /etc/yum.repos.d/ftp6.repo &amp;&amp; yum clean all &amp;&amp; yum repolist &amp;&amp; yum -y install openssh-server ---&gt; Using cache ---&gt; 4402742653b8 # 第二步完成后生成的镜像Step 3/5 : RUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/sshd stop &amp;&amp; echo &quot;root:123456&quot; | chpasswd ---&gt; Running in 41576869d2c5Generating SSH2 RSA host key: [ OK ]Generating SSH1 RSA host key: [ OK ]Generating SSH2 DSA host key: [ OK ]Starting sshd: [ OK ]Stopping sshd: [ OK ]Removing intermediate container 41576869d2c5 ---&gt; f84b609cb2a8 # 第三步完成后生成的镜像Step 4/5 : CMD [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;] ---&gt; Running in 453a0196b369Removing intermediate container 453a0196b369 ---&gt; fd7d7bdbd6eb # 第四步完成后生成的镜像Step 5/5 : EXPOSE 22 ---&gt; Running in 029d6942a429Removing intermediate container 029d6942a429 ---&gt; 0545dad565d5 # 第五步完成后生成的镜像Successfully built 0545dad565d5Successfully tagged centos6_10_add_sshd:latest# 上面的每一步都可以使用&quot;docker run -it --rm 镜像id /bin/bash&quot;进入容器内进行检查和调试[root@docker dockerfile]# docker image ls | grep centos6_10_add_sshdcentos6_10_add_sshd latest 0545dad565d5 About a minute ago 281MB 功能测试： 123456789# 使用刚制作的镜像启动容器，检查ssh服务和是否后端运行[root@docker dockerfile]# docker run -it -d --name ssh -p 222:22 0545dad565d5 e14f92e87ef27406e95001b66c2cd0736fcb181d3ec586bcebee62f24c43ce57# 查看容器ip地址[root@docker ~]# docker container inspect e14f92e87ef2 | grep IPAddress &quot;SecondaryIPAddresses&quot;: null, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, 使用xshell远程登录 6.3.2 制作lamp镜像其他常用命令格式： COPY–复制本地文件到容器指定目录下，支持通配符；如果拷贝的是一个目录，则只拷贝目录下的文件(将需要拷贝的文件放在dockefile同目录中) 格式：COPY &lt;src1,src2,·····&gt; ADD–跟COPY一样，多了一个功能是能自动解压.tar*的文件，并且还可以指定源文件为url地址，即可以进行网络下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102[root@docker bbs]# ls DiscuzX.tar dockerfile init.sh[root@docker bbs]# cat dockerfile # Centos6.10_SSHD_LAMP# 1 设置基础镜像，建议使用下面的写法，而不是使用tagFROM centos:centos6.10# 2 添加需要执行的程序等RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e &quot;[ftp6]\\nname=ftp6\\nbaseurl=ftp://172.17.0.1/centos6.10\\nenabled=1\\ngpgcheck=0&quot; &gt; /etc/yum.repos.d/ftp6.repo &amp;&amp; yum clean all &amp;&amp; yum repolist &amp;&amp; yum -y install openssh-server mysql mysql-server php php-mysql httpdRUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/sshd stop &amp;&amp; echo &quot;root:123456&quot; | chpasswd &amp;&amp; /etc/init.d/mysqld start &amp;&amp; /etc/init.d/httpd startRUN mysql -e &quot;grant all on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant all on *.* to root@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;grant all on *.* to discuz@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant all on *.* to discuz@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;create database discuz charset utf8;&quot;# 3 添加脚本启动文件到容器内COPY init.sh /# 4 添加bbs文件到http服务根目录下，并测试下载功能ADD DiscuzX.tar /var/wwww/htmlADD /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo /tmpRUN chmod -R 777 /var/www/html/# 5 暴露端口EXPOSE 22EXPOSE 80EXPOSE 3306# 6 容器启动时指定的命令CMD [&quot;/bin/bash&quot;,&quot;/init.sh&quot;][root@docker bbs]# docker build -t &quot;centos6_bbs&quot; ./···ERROR 2002 (HY000): Can&#x27;t connect to local MySQL server through socket &#x27;/var/lib/mysql/mysql.sock&#x27; (2)The command &#x27;/bin/sh -c mysql -e &quot;grant all on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant all on *.* to root@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;grant all on *.* to discuz@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant all on *.* to discuz@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;create database discuz charset utf8;&quot;&#x27; returned a non-zero code: 1# 报错信息/bin/sh -c mysql是因为调用了/bin/sh下的MySQL命令，但MySQL不是默认的shell命令，因此失败# 我们将MySQL执行命令放在init.sh脚本中[root@docker bbs]# cat init.sh #!/bin/bash/etc/init.d/mysqld startmysql -e &quot;grant all on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant all on *.* to root@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;grant all on *.* to discuz@&#x27;%&#x27; identified by &#x27;123456&#x27;;grant all on *.* to discuz@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;create database discuz charset utf8;&quot;/etc/init.d/httpd start/usr/sbin/sshd -D# 修改完成后重新执行制作命令[root@docker bbs]# docker build -t &quot;centos6_bbs&quot; ./Sending build context to Docker daemon 49.31MBStep 1/11 : FROM centos:centos6.10 ---&gt; 48650444e419Step 2/11 : RUN mv /etc/yum.repos.d/*.repo /tmp &amp;&amp; echo -e &quot;[ftp6]\\nname=ftp6\\nbaseurl=ftp://172.17.0.1/centos6.10\\nenabled=1\\ngpgcheck=0&quot; &gt; /etc/yum.repos.d/ftp6.repo &amp;&amp; yum clean all &amp;&amp; yum repolist &amp;&amp; yum -y install openssh-server mysql mysql-server php php-mysql httpd ---&gt; Using cache ---&gt; 163443b96f08Step 3/11 : RUN /etc/init.d/sshd start &amp;&amp; /etc/init.d/sshd stop &amp;&amp; echo &quot;root:123456&quot; | chpasswd &amp;&amp; /etc/init.d/mysqld start &amp;&amp; /etc/init.d/httpd start ---&gt; Using cache ---&gt; 71532a0cbbdaStep 4/11 : COPY init.sh / ---&gt; Using cache ---&gt; 011557e246cfStep 5/11 : ADD DiscuzX.tar /var/wwww/html ---&gt; Using cache ---&gt; 8ae2ce18a6ffStep 6/11 : ADD http://mirrors.aliyun.com/repo/epel-6.repo /tmpDownloading [==================================================&gt;] 664B/664B ---&gt; dc80368ca4c2Step 7/11 : RUN chmod -R 777 /var/www/html/ ---&gt; Running in 13d05bf9d33bRemoving intermediate container 13d05bf9d33b ---&gt; e998a08aa223Step 8/11 : EXPOSE 22 ---&gt; Running in a5bf69187121Removing intermediate container a5bf69187121 ---&gt; 18c5b2acc666Step 9/11 : EXPOSE 80 ---&gt; Running in 66764f22d9f6Removing intermediate container 66764f22d9f6 ---&gt; 3ac56c1cb679Step 10/11 : EXPOSE 3306 ---&gt; Running in b4553364173cRemoving intermediate container b4553364173c ---&gt; 3df29b4dafc9Step 11/11 : CMD [&quot;/bin/bash&quot;,&quot;/init.sh&quot;] ---&gt; Running in 6ae503afeed2Removing intermediate container 6ae503afeed2 ---&gt; 73c23cdfae10Successfully built 1a47917b0eb0Successfully tagged centos6_bbs:latest # 制作成功[root@docker bbs]# docker image ls | grep centos6_bbsREPOSITORY TAG IMAGE ID CREATED SIZEcentos6_bbs latest 1a47917b0eb0 About a minute ago 433MB[root@docker bbs]# docker run -d --name centos_bbs -p 8080:80 -p 222:22 -p 13306:3306 1a47917b0eb01d4302e50b3a283eba4fb480634969e4e23745eafa42981b0e8b8b639a250c36[root@docker ~]# docker exec -it 1d4302e50b3a /bin/bash[root@1d4302e50b3a /]# ls /var/www/html/readme/ README.md upload/ utility/ [root@1d4302e50b3a /]# ls /var/www/html/readme README.md upload utility # 打包的bbs文件，应该只包含repload目录即可，其他文件可不打包传递 浏览器安装(这里只做测试，不截屏)： 安装完成后，如下： 6.3.3 其他镜像制作命令 WORKDIR–指定工作目录 格式： WORKDIR /data/ ENV–设置环境变量 VOLUME–设置数据卷 ENTRYPOINT–跟CMD命令类似，但是CMD执行的命令可以在启动容器时被命令行命令取代，但ENTRYPOINT后面的命令不能被替换掉，即永远会执行镜像中指定的第一命令 可以通过doker image inspect 镜像名查看镜像制作的向下命令参数 –补充-6.3.4 环境镜像–java环境镜像镜像分类： 基础镜像，如centos、Ubuntu等 环境镜像，如java环境、python环境 项目镜像，将项目与环境镜像一起打包，等同于是从环境镜像而来 构建docker镜像实战 1234[root@docker20 ~]# mkdir /Dockerfile/ &amp;&amp; cd /Dockerfile/ 6.4 docker镜像仓库Docker Registry： ​ 启动容器时，docker daemon会试图从本地获取相关镜像，本地镜像不存在时，其将从Registry中下载该镜像并保存到本地 Docker Registry分类： Registry用于保存docker镜像，包括镜像的层次结构和元数据，用户可自建Registry，也可以使用官方的Docker Hub仓库，分类如下： Sponsor Registry：第三方仓库，供客户和docker社区使用 Mirror Registry：第三方仓库，只供客户使用 Vendor Registry：由发布docker镜像的供应商提供的Registry Private Registry：通过设有防火墙和额外的安全层的私有实体提供的Registry，如VMware的harbor Docker Registry的构成—repository和index l Repository n 由特定的docker镜像的所有迭代版本组成的镜像仓库，一个Registry中包含多个Repository n Repository可分为“顶级仓库”和“用户仓库“，用户仓库的格式为“用户名/仓库名” n 每个镜像可以包含多个Tag(标签)，每个镜像内的Tag唯一 l Index n 维护用户账号、镜像的校验已经公共命名空间的信息 n 相当于为Registry提供了一个完成用户认证等功能的索引接口 Docker Registry的来源： Docker Registry中的镜像通常由开发人员制作（一般是基于基础镜像制作，基础镜像由专业人士制作，如docker官方人员），而后推送至“公共”或“私有”Registry上保存，供其他人员使用，例如“部署”到生产环境中。 镜像的生成途径： l Dockerfile l 基于容器制作 l Docker Hub automated builds 6.4.1 制作本地镜像仓库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293[root@VM_16_8_centos ~]# docker pull registryUsing default tag: latestlatest: Pulling from library/registrycbdbe7a5bc2a: Pull complete 47112e65547d: Pull complete 46bcb632e506: Pull complete c1cc712bcecd: Pull complete 3db6272dcbfa: Pull complete Digest: sha256:8be26f81ffea54106bae012c6f349df70f4d5e7e2ec01b143c46e2c03b9e551dStatus: Downloaded newer image for registry:latestdocker.io/library/registry:latest[root@VM_16_8_centos ~]# docker image save -o registry.tar 8be26f81ffe# 将镜像上传到docker测试服务器并导入镜像[root@docker ~]# docker image load -i registry.tar 3e207b409db3: Loading layer [==================================================&gt;] 5.879MB/5.879MBf5b9430e0e42: Loading layer [==================================================&gt;] 817.2kB/817.2kB239a096513b5: Loading layer [==================================================&gt;] 20.08MB/20.08MBa5f27630cdd9: Loading layer [==================================================&gt;] 3.584kB/3.584kBb3f465d7c4d1: Loading layer [==================================================&gt;] 2.048kB/2.048kBLoaded image ID: sha256:2d4f4b5309b1e41b4f83ae59b44df6d673ef44433c734b14c1c103ebca82c116[root@docker bbs]# docker image ls | grep registryregistry latest 2d4f4b5309b1 4 weeks ago 26.2MB# 启动该镜像容器，--restart=always表示无论时服务器重启或者是docker服务重启之后都自动重启该容器，即该容器会自启[root@docker ~]# docker run -d -p 5000:5000 --restart=always --name registry -v /opt/registry:/var/lib/registry registry07da1db7effae881bc22570542efc2065a98d863e08b0a109e71087a9c9615ac# 设置仓库地址为本机地址，默认是docker hub，这里设置成本机(刚刚启动的容器)[root@docker ~]# vim /etc/docker/daemon.json # 注意格式&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;], # 多行内容以逗号结尾，json格式 &quot;insecure-registries&quot;: [&quot;10.138.3.15:5000&quot;] # 最后一行无逗号&#125;# 重启docker，重读配置文件[root@docker ~]# systemctl restart docker # 检查容器，发现也自动重启了[root@docker ~]# docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES07da1db7effa registry &quot;/entrypoint.sh /etc…&quot; 4 minutes ago Up 9 seconds 0.0.0.0:5000-&gt;5000/tcp registry# 重新给镜像打标签[root@docker ~]# docker image tag 5259a77d042b 10.138.3.15:5000/scaven/centos6_bbs:v1[root@docker ~]# docker image ls | grep 10.13810.138.3.15:5000/scaven/centos6_bbs v1 5259a77d042b 17 hours ago 477MB# 上传镜像[root@docker ~]# docker image ls | grep 10.13810.138.3.15:5000/scaven/centos6_bbs v1 5259a77d042b 17 hours ago 477MB[root@docker ~]# docker push 10.138.3.15:5000/scaven/centos6_bbs:v1The push refers to repository [10.138.3.15:5000/scaven/centos6_bbs]8028f132d224: Pushed b01adbd9e75d: Pushed 8088cb617267: Pushed v1: digest: sha256:57b830b668ca8de9f1eca19ecd1d84d9ca1892dbed4c67a10306ae9e556166e4 size: 950# 测试，下面是目录映射中的文件[root@docker ~]# ls /opt/registry/docker[root@docker ~]# ls /opt/registry/docker/registry/v2[root@docker ~]# ls /opt/registry/docker/registry/v2/blobs repositories# 测试，删除本机上的10.138.3.15:5000/scaven/centos6_bbs:v1镜像，然后从仓库中下载，先做备份再删除[root@docker ~]# docker image save -o registry_bbs.tar 5259a77d042b[root@docker ~]# docker image rm -f 5259a77d042b # 删除Untagged: 10.138.3.15:5000/scaven/centos6_bbs:v1Untagged: 10.138.3.15:5000/scaven/centos6_bbs@sha256:57b830b668ca8de9f1eca19ecd1d84d9ca1892dbed4c67a10306ae9e556166e4Untagged: scaven/centos6_bbs:v1Deleted: sha256:5259a77d042b9f0a2ca73f385603733d025b22c1ce3e549e1c25f95cd7c8bdcbDeleted: sha256:aa0085e1bee996bbffafae209a85ad2e7ee3e767cf43c9117728b761341efcc0[root@docker ~]# docker image ls | grep 5259a77d042b # 已删除成功[root@docker ~]# # 重新下载5259a77d042b镜像[root@docker ~]# docker pull 10.138.3.15:5000/scaven/centos6_bbs:v1v1: Pulling from scaven/centos6_bbs06a11a3d840d: Already exists 0bc80ff48944: Already exists c33df8f494cd: Pull complete Digest: sha256:57b830b668ca8de9f1eca19ecd1d84d9ca1892dbed4c67a10306ae9e556166e4Status: Downloaded newer image for 10.138.3.15:5000/scaven/centos6_bbs:v110.138.3.15:5000/scaven/centos6_bbs:v1[root@docker ~]# docker image ls | grep 5259a77d042b10.138.3.15:5000/scaven/centos6_bbs v1 5259a77d042b 17 hours ago 477MB 6.4.2 本地镜像仓库加密​ 上文6.4.1章节中的实现了镜像仓库的功能，但是任何人都能访问和上传镜像到仓库中，是十分不安全的，因此，我们应该给镜像仓库做加密，只有有密码的用户才能进行访问仓库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 在宿主机上执行[root@docker ~]# yum -y install httpd-tools[root@docker ~]# mkdir /opt/registry-auth[root@docker ~]# htpasswd -Bbn scaven 123456 &gt; /opt/registry-auth/htpasswd[root@docker ~]# cat /opt/registry-auth/htpasswd # 用户名：加密后的密码scaven:$2y$05$LAE/znxZd6RAXVgNrP6rJ.T5wv/JnmWL2D2QYfdUcCT9KSJfJKepS# 删除之前启动的仓库镜像，释放镜像，释放宿主机5000端口[root@docker ~]# docker container stop 07da1db7effa07da1db7effa# 按照下面的方式从新启动容器[root@docker ~]# docker run -d -p 5000:5000 -v /opt/registry-auth/:/auth/ -v /opt/registry:/var/lib/registry --name registry-auth -e &quot;REGISTRY_AUTH=htpasswd&quot; -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Regisry Realm&quot; -e &quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot; 2d4f4b5309b1c39b88dd0d44dc77529cb697a962c973e1543bf431270d222284cb2605701501[root@docker ~]# docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc39b88dd0d44 2d4f4b5309b1 &quot;/entrypoint.sh /etc…&quot; 8 seconds ago Up 7 seconds 0.0.0.0:5000-&gt;5000/tcp registry-auth# 现在直接推送就会失败[root@docker ~]# docker pull 10.138.3.15:5000/scaven/centos6_bbs:v1Error response from daemon: Get http://10.138.3.15:5000/v2/scaven/centos6_bbs/manifests/v1: no basic auth credential# 使用用户名和密码登录，登录后再推送镜像[root@docker ~]# docker login 10.138.3.15:5000Username: scavenPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded[root@docker ~]# docker pull 10.138.3.15:5000/scaven/centos6_bbs:v1v1: Pulling from scaven/centos6_bbsDigest: sha256:57b830b668ca8de9f1eca19ecd1d84d9ca1892dbed4c67a10306ae9e556166e4Status: Image is up to date for 10.138.3.15:5000/scaven/centos6_bbs:v110.138.3.15:5000/scaven/centos6_bbs:v1# 删除本地镜像进行下载验证[root@docker ~]# docker image ls | grep 10.138.3.15:5000/scaven/centos6_bbs10.138.3.15:5000/scaven/centos6_bbs v15259a77d042b 18 hours ago 477MB[root@docker ~]# docker image rm -f 10.138.3.15:5000/scaven/centos6_bbs:v1 # 从本地服务器上删除指定镜像Untagged: 10.138.3.15:5000/scaven/centos6_bbs:v1Untagged: 10.138.3.15:5000/scaven/centos6_bbs@sha256:57b830b668ca8de9f1eca19ecd1d84d9ca1892dbed4c67a10306ae9e556166e4Deleted: sha256:5259a77d042b9f0a2ca73f385603733d025b22c1ce3e549e1c25f95cd7c8bdcbDeleted: sha256:aa0085e1bee996bbffafae209a85ad2e7ee3e767cf43c9117728b761341efcc0# 从10.138.3.15:5000中下载镜像[root@docker ~]# docker pull 10.138.3.15:5000/scaven/centos6_bbs:v1v1: Pulling from scaven/centos6_bbs06a11a3d840d: Already exists 0bc80ff48944: Already exists c33df8f494cd: Pull complete Digest: sha256:57b830b668ca8de9f1eca19ecd1d84d9ca1892dbed4c67a10306ae9e556166e4Status: Downloaded newer image for 10.138.3.15:5000/scaven/centos6_bbs:v110.138.3.15:5000/scaven/centos6_bbs:v1[root@docker ~]# docker image ls | grep 10.138.3.15:5000/scaven/centos6_bbs # 下载成功10.138.3.15:5000/scaven/centos6_bbs v1 5259a77d042b 18 hours ago 477MB 6.5 harbor镜像仓库安装和使用​ Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等 特征： 云本机注册表：Harbour 支持容器映像和Helm图表，可用作云本机环境（如容器运行时和业务流程平台）的注册表。 基于角色的访问控制：用户和存储库通过“项目”进行组织，用户可以对项目下的图像拥有不同的权限。 基于策略的映像复制：可以基于具有多个过滤器（存储库，标记和标签）的策略在多个注册表实例之间复制（同步）映像。如果遇到任何错误，Harbor将自动重试进行复制。非常适合负载平衡，高可用性，多数据中心，混合和多云场景。 漏洞扫描：Harbor定期扫描图像并警告用户漏洞。 LDAP / AD支持：Harbor与现有企业LDAP / AD集成以进行用户身份验证和管理，并支持将LDAP组导入Harbor并为其分配适当的项目角色。 图像删除和垃圾收集：可以删除图像，并可以回收它们的空间。 公证：可以确保图像的真实性。 图形用户门户：用户可以轻松浏览，搜索存储库和管理项目。 审计：跟踪存储库的所有操作。 RESTful API：适用于大多数管理操作的RESTful API，易于与外部系统集成。 易于部署：提供在线和离线安装程序。 官方文档：https://goharbor.io/docs/ github用户手册：https://github.com/goharbor/harbor/blob/master/docs/user_guide.md 6.5.1安装步骤：6.5.1.1 安装docker12345678910111213# 安装docker[root@harbor ~]# wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -P /etc/yum.repos.d/[root@harbor ~]# yum clean all &amp;&amp; yum repolist[root@harbor ~]# yum -y install docker-ce# 指定镜像加速器和docker仓库[root@harbor harbor]# vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;: [&quot;10.138.3.33&quot;], &quot;live-restore&quot;: true&#125;[root@harbor ~]# systemctl enable docker &amp;&amp; systemctl restart docker 6.5.1.2安装docker-compose​ harbor依赖编排工具docker-compose，安装docker-compose有源码安装和pip安装两种安装方式，这里采用源码安装 下载源码安装(可以指定版本)： 网址：https://github.com/docker/compose/releases 123456789# 1、下载指定版本的docker-compose[root@harbor ~]# curl -L https://github.com/docker/compose/releases/download/1.23.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 下载较慢,注意上面的版本信息由于版本更改可能访问不到，因此可访问https://github.com/docker/compose/releases# 2、对二进制文件赋可执行权限[root@harbor ~]# chmod +x /usr/local/bin/docker-compose# 3、测试下docker-compose是否安装成功[root@harbor ~]# docker-compose --versiondocker-compose version 1.23.2, build 1110ad01 pip安装： 123456[root@harbor ~]# yum install python-pip -y[root@harbor ~]# pip install --upgrade pip[root@harbor ~]# pip install docker-compose #默认最新版本，可以使用 docker-compose&#x3D;&#x3D;version指定安装版本[root@harbor ~]# docker-compose --version docker-compose version 1.23.2, build 1110ad0 6.5.1.3 下载并安装harbor下载地址：https://github.com/goharbor/harbor/releases 服务器配置要求：2C/4G/40G，推荐4C/8G/160G 网址上提供了三种安装方式–离线安装、在线安装和源码安装，软件包较大，建议使用离线安装，这里采用离线安装，手动下载harbor安装包并上传到服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[root@harbor ~]# ls harbor-offline-installer-v1.10.4.tgz harbor-offline-installer-v1.10.4.tgz[root@harbor ~]# tar xf harbor-offline-installer-v1.10.4.tgz [root@harbor ~]# cd harbor[root@harbor harbor]# ls common.sh harbor.v1.10.4.tar.gz harbor.yml install.sh LICENSE prepare# 修改harbor配置文件hostname: 10.138.3.33 # IP地址或主机名http: # port for http, default is 80. If https enabled, this port will redirect to https port port: 80 # 默认是80端口，不修改harbor_admin_password: Harbor@2020 #Harbor超级管理员密码database: # The password for the root user of Harbor DB. Change this before any production use. password: root@123 #数据库管理员密码data_volume: /data #配置harbor数据文件，也就是未来镜像文件的存储位置，建议修改，不然直接占用系统盘空间。#同时注释如下内容，默认启用http，而不是https证书除非你有配置https证书# https related config#https: # https port for harbor, default is 443 #port: 443 # The path of cert and key files for nginx #certificate: /your/certificate/path #private_key: /your/private/key/path # 执行安装harbor脚步[root@harbor harbor]# ./install.sh[Step 0]: checking if docker is installed ...Note: docker version: 19.03.12[Step 1]: checking docker-compose is installed ...Note: docker-compose version: 1.23.2[Step 2]: loading Harbor images ...···[Step 5]: starting Harbor ... # 步骤5：启动harbor镜像容器Creating network &quot;harbor_harbor&quot; with the default driverCreating harbor-log ... done # 启动harbor-logCreating harbor-portal ... done # 启动harbor-portalCreating registryctl ... done # 启动registryctlCreating harbor-db ... done # 启动harbor-dbCreating registry ... done # 启动registryCreating redis ... done # 启动redisCreating harbor-core ... done # 启动harbor-coreCreating harbor-jobservice ... done # 启动harbor-jobserviceCreating nginx ... done # 启动nginx✔ ----Harbor has been installed and started successfully.----# 安装完成后，会在该目录下生成一个docker-compose.yml文件，这也是基于harbor.yml生成的供docker-compose调用创建容器的服务编排文件[root@harbor harbor]# lscommon common.sh docker-compose.yml harbor.v1.10.4.tar.gz harbor.yml install.sh LICENSE prepare# 此时，我们可以查看安装harbor时下载的镜像和启动的容器，如下图所示[root@harbor harbor]# docker image ls[root@harbor harbor]# docker container ls 浏览器登录： 首页如下： 新建项目，点击上图中’’新建项目’’： 点击项目名称scaven，进入该项目： 接下来，我们推送镜像到harbor仓库 12345678910111213141516171819202122232425262728293031323334353637# 给docker测试机执行镜像仓库[root@docker ~]# cat /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;: [&quot;10.138.3.15:5000&quot;,&quot;10.138.3.33:80&quot;]&#125; # 多个镜像仓库用逗号隔开即可，harbor默认使用的https协议，如果不加入insecure-registries则访问不了[root@docker ~]# systemctl daemon-reload[root@docker ~]# systemctl restart docker[root@docker ~]# docker-compose up -d # 如果有些harbor容器没有启动，则使用该命令重新启动下容器# 如果还是有问题，则使用docker-compose down停止所有harbor容器，然后再重启docker-compose up -d# 打标签[root@docker ~]# docker image ls | grep centos7.6centos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MB[root@docker ~]# docker tag f1cb7c7d58b7 10.138.3.33/scaven/centos:centos7.6.1810# 打完标签后，如下[root@docker ~]# docker image ls | grep centos7.610.138.3.33/scaven/centos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MBcentos centos7.6.1810 f1cb7c7d58b7 16 months ago 202MB# 上传，先登录，再上传[root@docker ~]# docker login 10.138.3.33:80Username: adminPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded[root@docker ~]# docker push 10.138.3.33:80/scaven/centos:centos7.6.1810The push refers to repository [10.138.3.33:80/scaven/centos]89169d87dbe2: Pushed centos7.6.1810: digest: sha256:747b2de199b6197a26eb1a24d69740d25483995842b2d2f75824095e9d1d19eb size: 529 完成后，可在web界面查看 点击上图中的镜像仓库scaven，进入仓库后，点击镜像名称scaven/centos，如下： 点击上图中的tag，进入镜像详情页面 七.补充7.1 docker网络详解思路：1.安装和启动docker前后，查看宿主机上网络的变化 ​ 2.启动一个容器后，查看容器内发收数据包与网桥docker0上新增的端口收发数据包的情况 7.1.1 安装和启动docker前后在未安装docker软件包之前，使用ip a查看宿主机网络信息如下： 12345678910111213141516171819202122[root@docker20 ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:46:24:04 brd ff:ff:ff:ff:ff:ff inet 10.138.3.130/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::9ecf:f41f:ee57:9f86/64 scope link noprefixroute valid_lft forever preferred_lft forever [root@docker20 ~]# iptables-save # iptables规则为空[root@docker20 ~]#[root@docker20 ~]# yum -y install bridge-utils # 网桥管理工具[root@docker20 ~]# brctl showbridge name bridge id STP enabled interfaces # 无数据信息[root@docker20 ~]# 安装docker软件包并启动docker(systemctl start docker)后，使用ip a查看宿主机网络信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[root@docker20 ~]# systemctl start docker[root@docker20 ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:46:24:04 brd ff:ff:ff:ff:ff:ff inet 10.138.3.130/24 brd 10.138.3.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::9ecf:f41f:ee57:9f86/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:d9:02:ec:81 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever [root@docker20 ~]# brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242d902ec81 no [root@docker20 ~]# iptables-save # Generated by iptables-save v1.4.21 on Tue Feb 16 14:11:28 2021*nat:PREROUTING ACCEPT [0:0]:INPUT ACCEPT [0:0]:OUTPUT ACCEPT [1:124]:POSTROUTING ACCEPT [1:124]:DOCKER - [0:0]-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE-A DOCKER -i docker0 -j RETURNCOMMIT# Completed on Tue Feb 16 14:11:28 2021# Generated by iptables-save v1.4.21 on Tue Feb 16 14:11:28 2021*filter:INPUT ACCEPT [17:1096]:FORWARD DROP [0:0]:OUTPUT ACCEPT [11:2692]:DOCKER - [0:0]:DOCKER-ISOLATION-STAGE-1 - [0:0]:DOCKER-ISOLATION-STAGE-2 - [0:0]:DOCKER-USER - [0:0]-A FORWARD -j DOCKER-USER-A FORWARD -j DOCKER-ISOLATION-STAGE-1-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT-A FORWARD -o docker0 -j DOCKER-A FORWARD -i docker0 ! -o docker0 -j ACCEPT-A FORWARD -i docker0 -o docker0 -j ACCEPT-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2-A DOCKER-ISOLATION-STAGE-1 -j RETURN-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP-A DOCKER-ISOLATION-STAGE-2 -j RETURN-A DOCKER-USER -j RETURNCOMMIT# Completed on Tue Feb 16 14:11:28 2021 有上述可知，在启动docker时，新建了一个名叫docker0的网桥 1234567891011121314151617181920212223242526[root@docker20 ~]# ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:55:5e:01:6e txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) # 显示接收的数据包，所有的容器都是通过docker0网桥接收的数据包，这里是汇总 RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) # 显示发送的数据包，所有的容器都是通过docker0网桥发送的数据包，这里是汇总 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.138.3.130 netmask 255.255.255.0 broadcast 10.138.3.255 inet6 fe80::9ecf:f41f:ee57:9f86 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:46:24:04 txqueuelen 1000 (Ethernet) RX packets 494 bytes 44022 (42.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 351 bytes 67796 (66.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 7.1.2 启动容器后此时我们启动一个容器，查看网桥docker0上新增端口数据包的变化 123456789101112131415161718192021222324252627282930# 上传镜像[root@docker20 ~]# ll -h total 358M-rw-------. 1 root root 1.7K Dec 13 18:01 anaconda-ks.cfg-rw-r--r-- 1 root root 1.4M Feb 15 18:33 busybox.tar-rw-r--r-- 1 root root 200M Feb 15 18:33 centos7.6.tar-rw-r--r-- 1 root root 131M Feb 15 18:33 nginx.tar-rw-r--r-- 1 root root 26M Feb 15 18:33 registry.tar# 导入镜像[root@docker20 ~]# docker image ls # 查看现有镜像，显示无镜像REPOSITORY TAG IMAGE ID CREATED SIZE[root@docker20 ~]# docker load -i busybox.tar # 导入busybox镜像50761fe126b6: Loading layer [==================================================&gt;] 1.442MB/1.442MBLoaded image: busybox:latest[root@docker20 ~]# docker load -i nginx.tar 13cb14c2acd3: Loading layer [==================================================&gt;] 72.49MB/72.49MB0e32546a8af0: Loading layer [==================================================&gt;] 64.16MB/64.16MB7ef35766ef7d: Loading layer [==================================================&gt;] 3.072kB/3.072kB4856db5e4f59: Loading layer [==================================================&gt;] 4.096kB/4.096kB2808ec4a8ea7: Loading layer [==================================================&gt;] 3.584kB/3.584kBLoaded image: nginx:latest[root@docker20 ~]# docker load -i centos7.6.tar 89169d87dbe2: Loading layer [==================================================&gt;] 209.5MB/209.5MBLoaded image: centos:centos7.6.1810[root@docker20 ~]# docker image ls # 导入后，查看宿主机上的镜像REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 0901fa9da894 7 months ago 132MBbusybox latest c7c37e472d31 7 months ago 1.22MBcentos centos7.6.1810 f1cb7c7d58b7 23 months ago 202MB 启动容器： 123456789101112131415161718192021222324[root@docker20 ~]# docker run -d -p 80:80 --name web01 0901fa9da894ed8ac3e3190d411b5485d9dd58563cb503235c4d3c2b8e4ed0301c163d1c8bc2[root@docker20 ~]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESed8ac3e3190d 0901fa9da894 &quot;/docker-entrypoint.…&quot; 39 minutes ago Up 39 minutes 0.0.0.0:80-&gt;80/tcp web01[root@docker20 ~]# brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242555e016e no vethb8545fb # 启动容器后，docker0上新增了一个端口[root@docker20 ~]# brctl showbridge name bridge id STP enabled interfacesdocker0 8000.0242555e016e no veth830784a[root@docker20 ~]# ifconfig veth830784aveth830784a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::38dc:e3ff:fe14:a6fc prefixlen 64 scopeid 0x20&lt;link&gt; ether 3a:dc:e3:14:a6:fc txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8 bytes 656 (656.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 启动完成后，使用windows主机访问nginx网页 此时查看docker0中新增端口的网络流量跟nginx容器的网络流量 123456789101112131415161718192021# docker0中新增端口的网络流量：[root@docker20 ~]# ifconfig veth830784aveth830784a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::38dc:e3ff:fe14:a6fc prefixlen 64 scopeid 0x20&lt;link&gt; ether 3a:dc:e3:14:a6:fc txqueuelen 0 (Ethernet) RX packets 81 bytes 4314 (4.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 89 bytes 5890 (5.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0# 查看nginx容器的网络流量：首先进入nginx容器中，然后执行ifconfig命令，最后对比数据包的大小[root@docker20 ~]# docker cp /usr/sbin/ifconfig ed8ac3e3190d:/usr/sbin # 将ifconfig命令导入到容器中[root@docker20 ~]# docker exec -it ed8ac3e3190d bash # 进入容器root@ed8ac3e3190d:/# ifconfig eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 89 bytes 5890 (5.7 KiB) # 流出的流量，对应网桥docker0新增端口veth830784a流入的流量 RX errors 0 dropped 0 overruns 0 frame 0 TX packets 81 bytes 4314 (4.2 KiB) # 流入的流量，对应网桥docker0新增端口veth830784a流出的流量 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 此时截图如下： 7.2 同台宿主机上两个容器的数据包走向思路：在同台宿主机上开启两个容器，在两个容器中互ping，查看流量走向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# 新建两个容器，并同时通过xshell界面连接进入容器[root@docker20 ~]# docker run -it -d --name Centos7-01 f1cb7c7d58b7 /bin/bash[root@docker20 ~]# docker run -it -d --name Centos7-02 f1cb7c7d58b7 /bin/bash[root@docker20 ~]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb8d07e8812fb f1cb7c7d58b7 &quot;/bin/bash&quot; 2 minutes ago Up 2 minutes Centos7-02a7495c7a321a f1cb7c7d58b7 &quot;/bin/bash&quot; 4 minutes ago Up 4 minutes Centos7-01# 进入容器1，并安装tcpdump[root@docker20 ~]# docker exec -it a7495c7a321a bash[root@a7495c7a321a /]# yum -y install tcpdump[root@a7495c7a321a /]# ifconfig eth0 eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 4015 bytes 13691921 (13.0 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3103 bytes 171543 (167.5 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0# 进入容器2，并安装tcpdump[root@docker20 ~]# docker exec -it b8d07e8812fb bash[root@b8d07e8812fb /]# yum -y install tcpdump[root@b8d07e8812fb /]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.3 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:03 txqueuelen 0 (Ethernet) RX packets 4423 bytes 13712937 (13.0 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3334 bytes 184083 (179.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0# 在容器2中ping容器1(容器2-b8d07e8812fb打开两个xhsell界面，一个用着ping，一个用着抓包)[root@b8d07e8812fb /]# ping 172.17.0.2 -c 1PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.188 ms--- 172.17.0.2 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.188/0.188/0.188/0.000 ms# 在ping的同时，在容器1和容器2以及宿主机上执行tcpdump命令，分别查看容器1和容器2中网卡eth0和宿主机上对应容器1和容器2的端口和docker0的icmp流量的情况## 1. 容器1中eth0的抓包情况[root@a7495c7a321a /]# tcpdump -i eth0 icmptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes13:08:06.501115 IP 172.17.0.3 &gt; a7495c7a321a: ICMP echo request, id 113, seq 1, length 6413:08:06.501171 IP a7495c7a321a &gt; 172.17.0.3: ICMP echo reply, id 113, seq 1, length 64## 2. 与容器1中eth0对应的接口veth5526b5c的抓包情况[root@docker20 ~]# tcpdump -i veth5526b5c icmptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on veth5526b5c, link-type EN10MB (Ethernet), capture size 262144 bytes21:08:06.501112 IP 172.17.0.3 &gt; 172.17.0.2: ICMP echo request, id 113, seq 1, length 6421:08:06.501173 IP 172.17.0.2 &gt; 172.17.0.3: ICMP echo reply, id 113, seq 1, length 64## 3. 容器2中eth0的抓包情况[root@b8d07e8812fb /]# tcpdump -i eth0 icmptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes13:08:06.501012 IP b8d07e8812fb &gt; 172.17.0.2: ICMP echo request, id 113, seq 1, length 6413:08:06.501181 IP 172.17.0.2 &gt; b8d07e8812fb: ICMP echo reply, id 113, seq 1, length 64## 4. 容器2中eth0对应的接口veth1abfdc9的抓包情况[root@docker20 ~]# tcpdump -i veth1abfdc9 icmp tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on veth1abfdc9, link-type EN10MB (Ethernet), capture size 262144 bytes21:08:06.501046 IP 172.17.0.3 &gt; 172.17.0.2: ICMP echo request, id 113, seq 1, length 6421:08:06.501180 IP 172.17.0.2 &gt; 172.17.0.3: ICMP echo reply, id 113, seq 1, length 64## 5. 宿主机docker0的抓包情况[root@docker20 ~]# tcpdump -i docker0 icmptcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes21:08:06.501046 IP 172.17.0.3 &gt; 172.17.0.2: ICMP echo request, id 113, seq 1, length 6421:08:06.501173 IP 172.17.0.2 &gt; 172.17.0.3: ICMP echo reply, id 113, seq 1, length 64# 此时，宿主机和容器1和容器2中的路由信息如下：[root@docker20 ~]# route -n Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.138.3.2 0.0.0.0 UG 100 0 0 ens3310.138.3.0 0.0.0.0 255.255.255.0 U 100 0 0 ens33172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0[root@a7495c7a321a /]# route -n Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.17.0.1 0.0.0.0 UG 0 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0[root@b8d07e8812fb /]# route -n Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.17.0.1 0.0.0.0 UG 0 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0 ​ 由上述四个网卡和一个网桥的抓包情况可以看出，同一台宿主机上同网段容器之间是通过网桥docker0直接互通，流程图如下： 网络流量走向总结： ​ 我们在容器2中ping容器1，首先在容器2中查询路由表，得到最优路径(目标地址为172.17.0.2，是属于目标地址为172.17.0.0的路由表，因此会使用该路由信息进行数据传递)，此时流量是从容器2的eth0网卡走向容器2对应在docker0上的接口veth1abfdc9，达到网桥docker0后，发现是同网段的ip地址，通过查询mac地址表，找出容器1的IP地址对应的mac地址，将数据包通过docker0上与容器1相连接的veth5526b5c端口将数据发送给容器1的网卡，数据包返回时操作流程也是一样。 7.3 容器连接外网时的数据包走向–源地址转换 思路：在容器1(IP地址为172.17.0.3)中ping百度，抓取容器2的网卡、docker0、ens33，查看数据包的走向 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# ping百度[root@b8d07e8812fb /]# ping baidu.com -c 2PING baidu.com (220.181.38.148) 56(84) bytes of data.64 bytes from baidu.com (220.181.38.148): icmp_seq=1 ttl=127 time=12.2 ms64 bytes from baidu.com (220.181.38.148): icmp_seq=2 ttl=127 time=9.94 ms--- baidu.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1004msrtt min/avg/max/mdev = 9.942/11.119/12.296/1.177 ms# 抓包情况## 1.容器2中eth0的抓包和路由信息[root@b8d07e8812fb /]# tcpdump -i eth0 icmp -w eth0.cap # 将输出信息保存到eth0.cap中，tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes^C4 packets captured4 packets received by filter0 packets dropped by kernel[root@b8d07e8812fb /]# route -n Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.17.0.1 0.0.0.0 UG 0 0 0 eth0 # 走这一条路由172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0## 2.宿主机上docker0的抓包[root@docker20 ~]# tcpdump -i docker0 icmp -w docker0.captcpdump: listening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes^C14 packets captured14 packets received by filter0 packets dropped by kernel## 3.宿主机上ens33的抓包[root@docker20 ~]# tcpdump -i ens33 icmp -w ens33.captcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes^C4 packets captured4 packets received by filter0 packets dropped by kernel[root@docker20 ~]# docker cp b8d07e8812fb:/eth0.cap . # 将容器中的eth0.cap拷贝到宿主机上[root@docker20 ~]# ll -h *.cap # 导出，通过wireshark打开数据包，进行网络走向分析-rw-r--r-- 1 tcpdump tcpdump 480 Feb 15 22:55 docker0.cap-rw-r--r-- 1 tcpdump tcpdump 480 Feb 15 22:55 ens33.cap-rw-r--r-- 1 root root 480 Feb 15 22:55 eth0.cap## 4.宿主机的iptables规则[root@docker20 ~]# iptables-save# Generated by iptables-save v1.4.21 on Mon Feb 15 21:39:23 2021*filter:INPUT ACCEPT [4043:876124]:FORWARD DROP [0:0]:OUTPUT ACCEPT [2946:334234]:DOCKER - [0:0]:DOCKER-ISOLATION-STAGE-1 - [0:0]:DOCKER-ISOLATION-STAGE-2 - [0:0]:DOCKER-USER - [0:0]-A FORWARD -j DOCKER-USER-A FORWARD -j DOCKER-ISOLATION-STAGE-1-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT-A FORWARD -o docker0 -j DOCKER-A FORWARD -i docker0 ! -o docker0 -j ACCEPT-A FORWARD -i docker0 -o docker0 -j ACCEPT-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2-A DOCKER-ISOLATION-STAGE-1 -j RETURN-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP-A DOCKER-ISOLATION-STAGE-2 -j RETURN-A DOCKER-USER -j RETURNCOMMIT# Completed on Mon Feb 15 21:39:23 2021# Generated by iptables-save v1.4.21 on Mon Feb 15 21:39:23 2021*nat:PREROUTING ACCEPT [146:9425]:INPUT ACCEPT [7:474]:OUTPUT ACCEPT [49:3260]:POSTROUTING ACCEPT [53:3596]:DOCKER - [0:0]-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE-A DOCKER -i docker0 -j RETURNCOMMIT# Completed on Mon Feb 15 21:39:23 2021 详解iptables规则：-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE，这条iptables规则是将源地址为172.17.0.0/16的数据包(也就是docker容器产生的数据包，容器的网关是docker0的地址，因此必然会经过docker0)，而不是docker0网卡直接发出的数据包，进行源地址转换，转换成docker主机网卡的地址，再发送出去 下面我们通过wireshark打开三个文件，按照容器eth0--&gt;docker0--&gt;ens33查看数据包流出(即请求信息request)情况，再通过ens33--&gt;docker0--&gt;容器eth0查看数据包流入(即回复信息reply)情况 7.3.1 数据包流出(request)情况eth0.cap的流量流出走向 docker0的流量流出走向 ens33的流量流出走向 7.3.2 数据包流入(reply)情况ens33.cap数据包流入： docker0.cap数据包流入： eth0.cap的流量流入： 因此数据流量的走向如下图所示： 总结：容器2在ping百度的时候，查询路由表，发现要达到百度需要通过目标地址为0.0.0.0 的路由，因此将数据包发送给容器2的网卡eth0，eth0将数据包发送到网桥docker0上的端口veth1abfdc9，此时，由于目标地址不是同网段，因此就不能直接广播了，就需要将数据包通过docker0转发出去，此时Linux的iptables规则就发挥作用了，首先通过snat规则将数据包传输到公网上，待百度服务器响应后，再将数据包传输给容器2的网卡，最后完成数据包的传递。 7.4 容器连接外网时的数据包走向–目标地址转换 思路：启动一个CentOS7的容器，通过外网访问(SSH协议)该容器，查看访问过程 启动容器 1234567891011121314151617181920[root@docker20 ~]# docker run -td -p 10.138.3.130:20022:22 --name Centos7-ssh f1cb7c7d58b7 /bin/bash40c86bbddc3a9ab53ddd2742f29e5abc7b48796c37fad26b126706bf5d9857ea[root@docker20 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES40c86bbddc3a f1cb7c7d58b7 &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds 10.138.3.130:20022-&gt;22/tcp Centos7-ssh[root@docker20 ~]# docker port 40c86bbddc3a22/tcp -&gt; 10.138.3.130:20022[root@docker20 ~]# docker exec -it 40c86bbddc3a bash# 安装并启动openssh服务[root@40c86bbddc3a init.d]# yum -y install openssh*[root@40c86bbddc3a init.d]# ./sshd start[root@40c86bbddc3a ~]# netstat -lntp Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 227/sshd tcp6 0 0 :::22 :::* LISTEN 227/sshd [root@40c86bbddc3a ~]# echo &quot;root:root&quot; | chpasswd # 给root用户设置密码为root 此时就可以通过xshell进行远程连接了 我们通过抓包，查看数据包流量走向 123456789101112131415161718192021222324# 容器的数据包[root@40c86bbddc3a ~]# tcpdump -i eth0 -w eth0.captcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes^C36 packets captured36 packets received by filter0 packets dropped by kernel[root@40c86bbddc3a ~]# ll total 12-rw------- 1 root root 3322 Dec 4 2018 anaconda-ks.cfg-rw-r--r-- 1 tcpdump tcpdump 7988 Feb 16 02:56 eth0.cap# 宿主机上docker0的数据包[root@docker20 ~]# tcpdump -i docker0 -w docker0.captcpdump: listening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes^C40 packets captured40 packets received by filter0 packets dropped by kernel# 宿主机上ens33的数据包[root@docker20 ~]# tcpdump -i ens33 -w ens33.captcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes^C74 packets captured76 packets received by filter0 packets dropped by kernel 将容器和宿主机上的数据包传输到pc上通过Wireshark打开 ens33.cap的信息 docker0.cap的信息 eth0.cap的信息 通过上述抓包可以知道，ens33到docker0之间进行了目标地址和端口转换 流程图如下所示： 此时docker主机上的iptables规则如下： 123456789101112131415161718192021222324252627282930313233343536373839[root@docker20 ~]# iptables-save # Generated by iptables-save v1.4.21 on Tue Feb 16 11:25:21 2021*nat:PREROUTING ACCEPT [119:7629]:INPUT ACCEPT [21:1394]:OUTPUT ACCEPT [4:267]:POSTROUTING ACCEPT [9:527]:DOCKER - [0:0]-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE-A POSTROUTING -s 172.17.0.2/32 -d 172.17.0.2/32 -p tcp -m tcp --dport 22 -j MASQUERADE-A DOCKER -i docker0 -j RETURN-A DOCKER -d 10.138.3.130/32 ! -i docker0 -p tcp -m tcp --dport 20022 -j DNAT --to-destination 172.17.0.2:22COMMIT# Completed on Tue Feb 16 11:25:21 2021# Generated by iptables-save v1.4.21 on Tue Feb 16 11:25:21 2021*filter:INPUT ACCEPT [2761:180272]:FORWARD DROP [0:0]:OUTPUT ACCEPT [2414:539236]:DOCKER - [0:0]:DOCKER-ISOLATION-STAGE-1 - [0:0]:DOCKER-ISOLATION-STAGE-2 - [0:0]:DOCKER-USER - [0:0]-A FORWARD -j DOCKER-USER-A FORWARD -j DOCKER-ISOLATION-STAGE-1-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT-A FORWARD -o docker0 -j DOCKER-A FORWARD -i docker0 ! -o docker0 -j ACCEPT-A FORWARD -i docker0 -o docker0 -j ACCEPT-A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 22 -j ACCEPT-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2-A DOCKER-ISOLATION-STAGE-1 -j RETURN-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP-A DOCKER-ISOLATION-STAGE-2 -j RETURN-A DOCKER-USER -j RETURNCOMMIT# Completed on Tue Feb 16 11:25:21 2021 解析DNAT规则：-A DOCKER -d 10.138.3.130/32 ! -i docker0 -p tcp -m tcp –dport 20022 -j DNAT –to-destination 172.17.0.2:22，意思是源地址是10.138.3.130，目标端口是20022，并且不是发送给docker0的数据包(在系统看来docker0和ens33是同一个网卡)，通过DNAT转换，将数据包发送给172.17.0.2的22号端口 7.5 几个常见的容器问题7.5.1 容器2引用容器1的网络，当容器1宕掉后，容器2的网络还能正常工作吗？答：不能。容器1宕掉后会销毁网络，因此容器2此时只有lo网络了，不再拥有与容器1共享的网络。 实验如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 清除掉所有容器[root@docker20 log]# docker container rm `docker container ls -a -q`[root@docker20 log]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@docker20 log]# # 1.新建容器1[root@docker20 ~]# docker run -td --name share-net f1cb7c7d58b7 bashead309a3e0bc3f769c6e08451bab0a47fb89106bf572d7751a7a0165624cdd69# 2.新建容器2，使容器2共享容器1的网络[root@docker20 ~]# docker run -td --name net-son --network container:share-net f1cb7c7d58b7 bash825c2559f41e7c5b0999feefd0630d1b4bdbe4e907e82ae94e5b521a84148d81# 3.检查两个容器是否同一个网络[root@docker20 ~]# docker container ls -a -q 825c2559f41eead309a3e0bc[root@docker20 ~]# docker cp /usr/sbin/ifconfig 825c2559f41e:/usr/sbin/[root@docker20 ~]# docker cp /usr/sbin/ifconfig ead309a3e0bc:/usr/sbin/[root@docker20 ~]# docker exec -it 825c2559f41e bash # 进入容器1[root@ead309a3e0bc /]# ifconfig eth0 # 容器1，将要被共享网络的容器eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 8 bytes 656 (656.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [root@docker20 ~]# docker exec -it 825c2559f41e bash[root@ead309a3e0bc /]# ifconfig eth0 #容器2，共享容器1网络的容器eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 8 bytes 656 (656.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0# 3.宕掉容器1，查看容器2的网络状况[root@docker20 ~]# docker container stop ead309a3e0bcead309a3e0bc[root@docker20 ~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES825c2559f41e f1cb7c7d58b7 &quot;bash&quot; 8 minutes ago Up 8 minutes net-sonead309a3e0bc f1cb7c7d58b7 &quot;bash&quot; 9 minutes ago Exited (137) 31 seconds ago share-net[root@ead309a3e0bc /]# ifconfig # 此时只有一个网络了，容器并没有退出lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0# 需要注意的是，如果容器1没有启动，是不能重启容器2的，因此容器2的启动依赖于容器1的网络，即启动的顺序是：容器1启动完成后，才能启动容器2[root@docker20 ~]# docker container restart 825c2559f41eError response from daemon: Cannot restart container 825c2559f41e: cannot join network of a non running container: ead309a3e0bc3f769c6e08451bab0a47fb89106bf572d7751a7a0165624cdd69 7.5.2 容器2引用容器1的存储卷(容器1引用宿主机存储卷)，当容器1宕掉后，容器2能继续使用存储卷吗？答：能。容器1宕掉并不影响容器2使用存储卷进行IO操作，也不影响容器2的运行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 清楚宿主机上的所有容器，并新建挂载目录和文件[root@docker20 ~]# docker container rm `docker container ls -a -q`825c2559f41eead309a3e0bc[root@docker20 ~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@docker20 ~]# [root@docker20 ~]# mkdir /data_docker/share[root@docker20 ~]# echo &quot;this is a volume test for container &quot; &gt; /data_docker/share/index.txt# 1.新建容器1，使容器1引用宿主机的目录[root@docker20 ~]# docker run -td --name c1 -v /data_docker/share:/tmp/ f1cb7c7d58b7 bash74e4ce2181ceafa348a06cc0b9d4c8940cd9400c4cb5402db13833b8f047d90d[root@docker20 ~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES74e4ce2181ce f1cb7c7d58b7 &quot;bash&quot; 7 seconds ago Up 6 seconds c1[root@docker20 ~]# docker exec -it 74e4ce2181ce bash [root@74e4ce2181ce /]# cat /tmp/index.txt this is a volume test for container # 2.新建容器2，使容器2引用容器1的存储卷[root@docker20 ~]# docker run -td --name c2 --volumes-from c1 f1cb7c7d58b7 bash6ae5346e6b5cffb51a974408300469f9526027a08adf8f3d9997824d499e10d9[root@docker20 ~]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6ae5346e6b5c f1cb7c7d58b7 &quot;bash&quot; 4 seconds ago Up 4 seconds c274e4ce2181ce f1cb7c7d58b7 &quot;bash&quot; 3 minutes ago Up 3 minutes c1[root@docker20 ~]# docker exec -it 6ae5346e6b5c bash # 进入容器c2[root@6ae5346e6b5c /]# cat /tmp/index.txt this is a volume test for container # 3.通过上述实验，我们已经知道c2和c1都能读取到宿主机上/data_docker/share/index.txt文件，此时我们宕掉c1容器[root@docker20 ~]# docker container stop 74e4ce2181ce74e4ce2181ce[root@docker20 ~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6ae5346e6b5c f1cb7c7d58b7 &quot;bash&quot; 2 minutes ago Up 2 minutes c274e4ce2181ce f1cb7c7d58b7 &quot;bash&quot; 6 minutes ago Exited (137) 10 seconds ago c1[root@docker20 ~]# dateTue Feb 16 13:04:01 CST 2021 # 此时宿主机的时间 # 此时容器c2中仍旧可以对存储卷进行读写[root@6ae5346e6b5c /]# date Tue Feb 16 05:04:45 UTC 2021[root@6ae5346e6b5c /]# echo &quot;`date`&quot; &gt;&gt; tmp/index.txt [root@6ae5346e6b5c /]# cat /tmp/index.txt this is a volume test for container Tue Feb 16 05:05:55 UTC 2021# 在宿主机上查看index.txt文件，内容如下[root@docker20 ~]# cat /data_docker/share/index.txt this is a volume test for container Tue Feb 16 05:05:55 UTC 2021# 4.如果我们重启c2容器，能成功吗？[root@docker20 ~]# docker container restart 6ae5346e6b5c # 在容器c1宕机的情况下可以启动容器c26ae5346e6b5c[root@docker20 ~]# echo $?0[root@docker20 ~]# docker exec -it 6ae5346e6b5c bash [root@6ae5346e6b5c /]# cat /tmp/index.txt this is a volume test for container Tue Feb 16 05:05:55 UTC 2021 结论：容器2引用容器1的存储卷时，当容器1宕机不影响容器2的IO操作和容器2的重启操作 有错？？7.5.3 同台宿主机，不同网桥上的两个容器的互通思路：新建一个名称为new_bridge的bridge网桥，分别用new_bridge网桥和默认的bridge网桥运行容器，并使用Linux内核的路由转发功能让这两个容器互通 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 1.清空宿主机上的所有容器[root@docker20 ~]# docker container rm `docker container ls -a -q`6ae5346e6b5c74e4ce2181ce# 2.新建docker网桥[root@docker20 ~]# docker network ls # docker宿主机上的默认网络NETWORK ID NAME DRIVER SCOPE84b07138ff9e bridge bridge localbca4b3029dbe host host localecd4e3687fb9 none null local[root@docker20 ~]# [root@docker20 ~]# docker network create new_bridge # 新建一个bridge网桥，名称为new_bridgec158263b11a08b4062dc21b5806141b017cf7a02d0eff4f57825a4064dc897eb[root@docker20 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE84b07138ff9e bridge bridge localbca4b3029dbe host host localc158263b11a0 new_bridge bridge localecd4e3687fb9 none null local# 3.新建两个不同网段的容器 ## 3.1新建容器c1[root@docker20 ~]# docker run -td --name c1 f1cb7c7d58b7 bash 60ffca766bdea3ba772bc8fff9e15a5b569d213d06980f1cb56b0d50a66315cf[root@docker20 ~]# docker cp /usr/sbin/ifconfig 60ffca766bde:/usr/sbin/## 3.2新建容器c2[root@docker20 ~]# docker run --name c2 --network new_bridge -td f1cb7c7d58b7 bash a2e14957ce3fe92a6b3fba5032039730dcfc5ba89be2ba1723ad9e0ca38c9a51[root@docker20 ~]# docker cp /usr/sbin/ifconfig a2e14957ce3f:/usr/sbin/[root@docker20 ~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa2e14957ce3f f1cb7c7d58b7 &quot;bash&quot; 38 seconds ago Up 37 seconds c260ffca766bde f1cb7c7d58b7 &quot;bash&quot; 6 minutes ago Up 6 minutes c1## 3.3进入容器c1，查看c1的IP地址，并ping容器c2[root@docker20 ~]# docker exec -it 60ffca766bde bash [root@60ffca766bde /]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 13 bytes 1102 (1.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [root@60ffca766bde /]# ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.^C--- 172.18.0.2 ping statistics ---2 packets transmitted, 0 received, 100% packet loss, time 1001ms## 3.4进入容器c2，查看c1的IP地址，并ping容器c1 [root@docker20 ~]# docker exec -it a2e14957ce3f bash[root@a2e14957ce3f /]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.18.0.2 netmask 255.255.0.0 broadcast 172.18.255.255 ether 02:42:ac:12:00:02 txqueuelen 0 (Ethernet) RX packets 13 bytes 1102 (1.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0[root@a2e14957ce3f /]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.^C--- 172.17.0.2 ping statistics ---3 packets transmitted, 0 received, 100% packet loss, time 2002ms# 4.清空防火墙规则，并开启路由转发功能[root@docker20 ~]# iptables -F[root@docker20 ~]# echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt; /etc/sysctl.conf[root@docker20 ~]# sysctl -pnet.ipv4.ip_forward = 1[root@docker20 ~]# route -n # 此时的路由表信息Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 10.138.3.2 0.0.0.0 UG 100 0 0 ens3310.138.3.0 0.0.0.0 255.255.255.0 U 100 0 0 ens33172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0172.18.0.0 0.0.0.0 255.255.0.0 U 0 0 0 br-c158263b11a0# 5.此处两个容器互ping不通？？？奇了怪了 7.5.4 新建网桥，默认可以通过主机名通信​ 默认网桥则不行，下面通过在同一网段(两个不同网桥)下ping另一个容器的主机名进行测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191[root@docker20 ~]# docker container rm -f `docker container ls -qa` # 删除该宿主机上的所有容器[root@docker20 ~]# docker network create new_netf72b4eaaf552cc24efc467f3b630031c86ab649c2e0318ac26de1f1d72b79f21[root@docker20 ~]# [root@docker20 ~]# docker network ls NETWORK ID NAME DRIVER SCOPEb3064d19f20d bridge bridge localbca4b3029dbe host host localf72b4eaaf552 new_net bridge local # 新建网桥，默认也是桥接ecd4e3687fb9 none null local[root@docker20 ~]# docker network inspect bridge[ &#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;b3064d19f20d631d2a7f3c298a4ee6583a1544ae15c7966f61941d26954670ef&quot;, &quot;Created&quot;: &quot;2021-04-01T10:59:13.315953055+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, # 默认网桥默认网段是172.17.0.0/16 &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123;&#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125; &#125;][root@docker20 ~]# docker network inspect new_net[ &#123; &quot;Name&quot;: &quot;new_net&quot;, &quot;Id&quot;: &quot;f72b4eaaf552cc24efc467f3b630031c86ab649c2e0318ac26de1f1d72b79f21&quot;, &quot;Created&quot;: &quot;2021-04-01T21:36:27.933857446+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;, # 网段，默认网段是172.18.0.0/16 &quot;Gateway&quot;: &quot;172.18.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123;&#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# 新建4个容器，不同网桥容器两个## 默认网桥[root@docker20 ~]# docker run -it busybox sh # 新建容器1/ # ifconfig eth0 eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:7 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:586 (586.0 B) TX bytes:0 (0.0 B)/ # hostname 14c9f17fe0fc[root@docker20 ~]# docker run -it busybox sh # 新建容器2/ # ifconfig eth0 eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:03 inet addr:172.17.0.3 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:6 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:516 (516.0 B) TX bytes:0 (0.0 B)/ # hostname a0532f2f769a/ # ping 172.17.0.3 -c 1 # 在容器1中ping容器2的IP地址，没有问题PING 172.17.0.3 (172.17.0.3): 56 data bytes64 bytes from 172.17.0.3: seq=0 ttl=64 time=0.049 ms--- 172.17.0.3 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.049/0.049/0.049 ms/ # ping a0532f2f769a # 在容器1中ping容器2的主机名，失败ping: bad address &#x27;a0532f2f769a&#x27;/ # ping 172.17.0.2 -c 1 # 在容器2中ping容器1的IP地址，没有问题PING 172.17.0.2 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=6.461 ms--- 172.17.0.2 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 6.461/6.461/6.461 ms/ # ping 14c9f17fe0fc # 在容器2中ping容器1的主机名，失败ping: bad address &#x27;14c9f17fe0fc&#x27;## 下面使用新建网桥new_net做实验[root@docker20 ~]# docker run -it --network new_net busybox sh # 新建容器1/ # ifconfig eth0 eth0 Link encap:Ethernet HWaddr 02:42:AC:12:00:02 inet addr:172.18.0.2 Bcast:172.18.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:13 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:1102 (1.0 KiB) TX bytes:0 (0.0 B)/ # hostname d0999162dce9[root@docker20 ~]# docker run -it --network new_net busybox sh # 新建容器2/ # ifconfig eth0 eth0 Link encap:Ethernet HWaddr 02:42:AC:12:00:03 inet addr:172.18.0.3 Bcast:172.18.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:7 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:586 (586.0 B) TX bytes:0 (0.0 B)/ # hostname f4743940a945# 在容器1中通过ping命令ping容器2IP地址和容器2主机名/ # ping 172.18.0.3 -c 1 # 在容器1中ping容器2IP地址成功PING 172.18.0.3 (172.18.0.3): 56 data bytes64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.094 ms--- 172.18.0.3 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.094/0.094/0.094 ms/ # / # ping f4743940a945 -c 1 # 在容器1中ping容器2主机名成功，并自动解析出IP地址PING f4743940a945 (172.18.0.3): 56 data bytes # 通过主机名f4743940a945解析出IP地址--172.18.0.364 bytes from 172.18.0.3: seq=0 ttl=64 time=0.057 ms--- f4743940a945 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.057/0.057/0.057 ms# 在容器2中通过Ping命令ping容器1的IP地址和主机名/ # ping 172.18.0.2 -c 1 # 在容器1中ping容器1IP地址成功PING 172.18.0.2 (172.18.0.2): 56 data bytes64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.050 ms--- 172.18.0.2 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.050/0.050/0.050 ms/ # ping d0999162dce9 -c 1 # 在容器2中ping容器1IP地址成功PING d0999162dce9 (172.18.0.2): 56 data bytes64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.060 ms--- d0999162dce9 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.060/0.060/0.060 ms ​ 我们知道，容器的IP地址是随着容器的启停会随时变化，那么在项目中通过IP地址定位容器的方式就不可取了，常用的做法是新建网桥，通过主机名相互识别相关联的项目容器。 7.6 联合文件系统​ 支持将不同位置的目录挂载到同一虚拟文件系统，形成一种分层的模型。 实际拓扑图如下： 写时复制(COW:copy on write)：当需要修改文件时，会先从镜像里把需要写的文件复制到自己的文件系统中进行修改 读写文件的顺序：先找容器层，如果有则复制到读写层进行读写，如果容器层没有，再去镜像层查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185[root@docker20 ~]# docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES60ffca766bde f1cb7c7d58b7 &quot;bash&quot; 6 weeks ago Up 2 hours c1[root@docker20 ~]# docker inspect f1cb7c7d58b7 # 查看镜像f1cb7c7d58b7的信息[ &#123; &quot;Id&quot;: &quot;sha256:f1cb7c7d58b73eac859c395882eec49d50651244e342cd6c68a5c7809785f427&quot;, &quot;RepoTags&quot;: [ &quot;centos:centos7.6.1810&quot; ], &quot;RepoDigests&quot;: [], &quot;Parent&quot;: &quot;&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2019-03-14T21:20:29.635970966Z&quot;, &quot;Container&quot;: &quot;cc6043a787f6d1c7ae3e121ebdf1c4478186336aa7274871780a0a7bcc3a061a&quot;, &quot;ContainerConfig&quot;: &#123; &quot;Hostname&quot;: &quot;cc6043a787f6&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop) &quot;, &quot;CMD [\\&quot;/bin/bash\\&quot;]&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:698a0848ee35389ab7b98494bdc60f887c54ddb94fc2326a1fb4eff8895aff43&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20181204&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;DockerVersion&quot;: &quot;18.06.1-ce&quot;, &quot;Author&quot;: &quot;&quot;, &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:698a0848ee35389ab7b98494bdc60f887c54ddb94fc2326a1fb4eff8895aff43&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20181204&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;Architecture&quot;: &quot;amd64&quot;, &quot;Os&quot;: &quot;linux&quot;, &quot;Size&quot;: 201763773, &quot;VirtualSize&quot;: 201763773, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; # 统一视图 &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/dd2431298d13cb0c936f162d2dcbf0868d9457f686ad0d12c7f1d07db28b10d2/merged&quot;, # 容器层 &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/dd2431298d13cb0c936f162d2dcbf0868d9457f686ad0d12c7f1d07db28b10d2/diff&quot;, # 工作目录 &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/dd2431298d13cb0c936f162d2dcbf0868d9457f686ad0d12c7f1d07db28b10d2/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;RootFS&quot;: &#123; &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:89169d87dbe2b72ba42bfbb3579c957322baca28e03a1e558076542a1c1b2b4a&quot; ] &#125;, &quot;Metadata&quot;: &#123; &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125; &#125;]# 查看UpperDir，没有上面新建的日期目录[root@docker20 ~]# ls /var/lib/docker/overlay2/dd2431298d13cb0c936f162d2dcbf0868d9457f686ad0d12c7f1d07db28b10d2/diff anaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var# 下面查看容器中的三层[root@docker20 ~]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES60ffca766bde f1cb7c7d58b7 &quot;bash&quot; 6 weeks ago Up About an hour c1[root@docker20 ~]# docker inspect 60ffca766bde···&quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1-init/diff:/var/lib/docker/overlay2/dd2431298d13cb0c936f162d2dcbf0868d9457f686ad0d12c7f1d07db28b10d2/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;,···[root@docker20 overlay2]# ls /var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1-init/diff# 查看&quot;LowerDir&quot;中的目录信息，etc下的hostname、hosts、resolv.conf这三个文件是挂载宿主机对应文件dev etc# 查看&quot;LowerDir&quot;中的目录/etc/目录中的信息[root@docker20 overlay2]# ls /var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1-init/diff/etc/hostname hosts mtab resolv.conf # [root@docker20 overlay2]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES60ffca766bde f1cb7c7d58b7 &quot;bash&quot; 6 weeks ago Up About an hour c1[root@docker20 overlay2]# docker exec -it 60ffca766bde bash[root@60ffca766bde /]# cat /etc/hostname # 容器的主机名60ffca766bde[root@60ffca766bde /]# cat /etc/resolv.conf # 容器的DNS解析文件，使用的是宿主机的# Generated by NetworkManagernameserver 10.138.3.2nameserver 8.8.8.8[root@60ffca766bde /]# cat /etc/hosts # 容器的域名解析文件，使用的是宿主机的，并添加了内容 127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.2 60ffca766bde[root@docker20 ~]# cat /etc/hosts # 宿主机的域名解析文件127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6[root@docker20 ~]# cat /etc/resolv.conf # 宿主机的DNS解析文件# Generated by NetworkManagernameserver 10.138.3.2nameserver 8.8.8.8[root@docker20 ~]# docker20[root@docker20 ~]# ls /var/lib/docker/overlay2/dd2431298d13cb0c936f162d2dcbf0868d9457f686ad0d12c7f1d07db28b10d2/diff/anaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var # 这个是容器中根文件下的目录[root@60ffca766bde /]# ls # 在容器里面查看/目录下的文件，跟上文一致anaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@docker20 ~]# ls / # 查看宿主机的/文件下的目录bin boot data_docker dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@60ffca766bde /]# mkdir `date +%F` # 在容器里面新建目录2021-03-31[root@60ffca766bde /]# ls 2021-03-31 anaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@docker20 ~]# ls /var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1/merged2021-03-31 anaconda-post.log bin dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@docker20 ~]# ls /var/lib/docker/overlay2/f008794742db7f159b4cf33b581b135e708d1133d729bb676395f92b62d06ba1/diff2021-03-31 root usr 如下图：","categories":[{"name":"docker","slug":"docker","permalink":"https://scaven.site/categories/docker/"}],"tags":[{"name":"kubernets","slug":"kubernets","permalink":"https://scaven.site/tags/kubernets/"}]},{"title":"welcome","slug":"welcome","date":"2021-04-20T02:11:08.000Z","updated":"2021-04-20T02:42:04.832Z","comments":true,"path":"2021-04/20-welcome/","link":"","permalink":"https://scaven.site/2021-04/20-welcome/","excerpt":"","text":"welcome to my blog!","categories":[{"name":"Home","slug":"Home","permalink":"https://scaven.site/categories/Home/"}],"tags":[{"name":"welcome","slug":"welcome","permalink":"https://scaven.site/tags/welcome/"}]},{"title":"docker-registory","slug":"docker-registory","date":"2021-04-19T01:09:44.000Z","updated":"2021-04-20T02:42:46.022Z","comments":true,"path":"2021-04/19-docker-registory/","link":"","permalink":"https://scaven.site/2021-04/19-docker-registory/","excerpt":"","text":"第一章 docker私有仓库–harbor的搭建1. harbor是什么1.1 harbor简介​ Harbor是由VMware公司开源的一个用于存储和分发Docker镜像的企业级docker镜像仓库，默认使用https访问协议。通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。 云本机注册表：Harbour 支持容器映像和Helm图表，可用作云本机环境（如容器运行时和业务流程平台）的注册表。 基于角色的访问控制：用户和存储库通过“项目”进行组织，用户可以对项目下的图像拥有不同的权限。 基于策略的映像复制：可以基于具有多个过滤器（存储库，标记和标签）的策略在多个注册表实例之间复制（同步）映像。如果遇到任何错误，Harbor将自动重试进行复制。非常适合负载平衡，高可用性，多数据中心，混合和多云场景。 漏洞扫描：Harbor定期扫描图像并警告用户漏洞。 LDAP / AD支持：Harbor与现有企业LDAP / AD集成以进行用户身份验证和管理，并支持将LDAP组导入Harbor并为其分配适当的项目角色。 图像删除和垃圾收集：可以删除图像，并可以回收它们的空间。 公证：可以确保图像的真实性。 图形用户门户：用户可以轻松浏览，搜索存储库和管理项目。 审计：跟踪存储库的所有操作。 RESTful API：适用于大多数管理操作的RESTful API，易于与外部系统集成。 易于部署：提供在线和离线安装程序。 官方文档：https://goharbor.io/docs/ github用户手册：https://github.com/goharbor/harbor/blob/master/docs/user_guide.md 官网：https://harbor.com/ 1.2 harbor组件： 组件 功能 harbor-adminserver 配置管理中心 harbor-db Mysql数据库 harbor-jobservice 负责镜像复制 harbor-log 记录操作日志 harbor-ui Web管理页面和API nginx 前端代理，负责前端页面和镜像上传/下载转发 redis 会话 registry 镜像存储 2 harbor下载与安装2.1 harbor下载服务器配置要求：2C/4G/40G，推荐4C/8G/160G 下载地址：https://github.com/goharbor/harbor/releases 2.1.1 安装方式 离线安装：下载harbor软件包到本地进行安装，软件包较大，下载速度慢 在线安装： OVA安装程序：当用户具有vCenter环境时，使用此安装程序，在部署OVA后启动Harbor。 2.2 harbor安装2.2.1 安装docker1234567891011121314151617181920212223# 如果已经安装了docker，可以使用下面的命令卸载# yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine # 安装必要的依赖包# yum install -y device-mapper-persistent-data lvm2# 添加docker仓库，并修改成国内清华镜像源# wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.repo # sed -i &#x27;s#download.docker.com#mirrors.tuna.tsinghua.edu.cn/docker-ce#&#x27; /etc/yum.repos.d/docker-ce.repo# yum clean all &amp;&amp; yum repolist# 安装docker# yum -y install docker-ce# 添加镜像加速器# mkdir /etc/docker# vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;]&#125;# 启动并添加到开机自启动# systemctl start docker &amp;&amp; systemctl enable docker 2.2.2 安装docker-compose​ harbor使用docker-compose进行编排，因此在安装harbor之前必须先安装docker-compose。 ​ 下载地址：https://github.com/docker/compose/releases 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# ls docker-compose-Linux-x86_64docker-compose-Linux-x86_64# 添加执行权限并移动到环境变量路径中# chmod u+x docker-compose-Linux-x86_64# mv docker-compose-Linux-x86_64 /usr/bin/docker-compose # 验证 # docker-compose --versiondocker-compose version 1.28.6, build 5db8d86f# docker-compose简单用法# docker-compose --helpDefine and run multi-container applications with Docker.Usage: docker-compose [-f &lt;arg&gt;...] [--profile &lt;name&gt;...] [options] [--] [COMMAND] [ARGS...] docker-compose -h|--helpOptions: -f, --file FILE Specify an alternate compose file (default: docker-compose.yml) -p, --project-name NAME Specify an alternate project name (default: directory name) --profile NAME Specify a profile to enable -c, --context NAME Specify a context name --verbose Show more output --log-level LEVEL Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) --ansi (never|always|auto) Control when to print ANSI control characters --no-ansi Do not print ANSI control characters (DEPRECATED) -v, --version Print version and exit -H, --host HOST Daemon socket to connect to --tls Use TLS; implied by --tlsverify --tlscacert CA_PATH Trust certs signed only by this CA --tlscert CLIENT_CERT_PATH Path to TLS certificate file --tlskey TLS_KEY_PATH Path to TLS key file --tlsverify Use TLS and verify the remote --skip-hostname-check Don&#x27;t check the daemon&#x27;s hostname against the name specified in the client certificate --project-directory PATH Specify an alternate working directory (default: the path of the Compose file) --compatibility If set, Compose will attempt to convert keys in v3 files to their non-Swarm equivalent (DEPRECATED) --env-file PATH Specify an alternate environment fileCommands: build Build or rebuild services # 构建或者重构服务 config Validate and view the Compose file create Create services # 创建服务 down Stop and remove resources # 停止运行中的容器 events Receive real time events from containers exec Execute a command in a running container # 进入一个运行的容器中 help Get help on a command images List images # 列出存在的所有镜像 kill Kill containers # kill掉容器 logs View output from containers # 查看容器日志输出 pause Pause services # 暂停服务 port Print the public port for a port binding # 列出端口 ps List containers # 列出运行中的容器 pull Pull service images # 推镜像到仓库 push Push service images # 从仓库中拉取镜像 restart Restart services # 重启服务 rm Remove stopped containers # 删除停止的容器 run Run a one-off command scale Set number of containers for a service start Start services # 启动服务 stop Stop services # 停止服务 top Display the running processes # 展示运行容器使用的资源信息 unpause Unpause services up Create and start containers # 启动容器 version Show version information and quit # 查看docker-compose版本信息 2.2.3 安装harbor​ harbor默认使用https协议进行访问，也支持http协议。因此接下来的安装过程将分成两个步骤，使用http协议和https协议进行harbor安装。 2.2.3.1 解压并认识harbor配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# ls harbor-offline-installer-v2.2.1.tgz# tar zxvf harbor-offline-installer-v2.2.1.tgz # 解压harbor/harbor.v2.2.1.tar.gzharbor/prepareharbor/LICENSEharbor/install.shharbor/common.shharbor/harbor.yml.tmpl # 配置文件样本# cat harbor.yml.tmpl | grep -Ev &quot;^$|#&quot; # 简单认识配置模板文件hostname: reg.mydomain.com # 默认的域名，使用该域名需要域名解析，如果不做域名解析，可修改成harbor主机IP地址http: # http信息，默认端口信息都可以自行修改 port: 80 https: # https的端口和证书存放路径，默认使用Https协议，但使用https需要配置证书，若不使用可注释掉 port: 443 certificate: /your/certificate/path private_key: /your/private/key/pathharbor_admin_password: Harbor12345 # 登陆harbor仓库web界面默认密码，默认用户为adamin，建议修改database: # 数据库信息 password: root123 # 数据库root用户密码，建议修改 max_idle_conns: 50 max_open_conns: 1000data_volume: /data # 默认存储位置trivy: ignore_unfixed: false skip_update: false insecure: falsejobservice: max_job_workers: 10notification: webhook_job_max_retry: 10chart: absolute_url: disabledlog: level: info local: rotate_count: 50 rotate_size: 200M location: /var/log/harbor_version: 2.2.0proxy: http_proxy: https_proxy: no_proxy: components: - core - jobservice - trivy 2.2.3.2 使用http协议访问harbor​ harbor默认使用https协议，如果不想使用https协议，可以修改/etc/docker/daemon.json文件。 123456# vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;: [&quot;10.138.3.111:80&quot;]&#125;# 将harbor主机IP地址(如果配置了域名解析可直接使用域名)和端口写入该文件，让其受信任即可 ​ 注释掉harbor.yml.tmpl文件中关于https的内容 12345# vim harbor.yml.tmpl # 注释掉该文件中下面的内容https: port: 443 certificate: /your/certificate/path private_key: /your/private/key/path 2.2.3.3 使用https协议访问harbor​ 使用https协议需要证书，接下来我们使用cfssl进行自签证书。 安装cfssl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64# wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64# wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64# 添加执行权限# chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64# 移动至环境变量路径mv cfssl_linux-amd64 /usr/local/bin/cfssl # 生成证书工具mv cfssljson_linux-amd64 /usr/local/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo # 证书信息查看工具# 验证# cfssl versionVersion: 1.2.0Revision: devRuntime: go1.6# 生成ca证书配置文件# mkdir ssl# cd ssl &amp;&amp; cfssl print-defaults config &gt; ca-config.json # cat ca-config.json&#123; &quot;signing&quot;: &#123; &quot;default&quot;: &#123; &quot;expiry&quot;: &quot;168h&quot; # 过期时间，默认为168h，此处修改成87600h=10年 &#125;, &quot;profiles&quot;: &#123; &quot;www&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot;, # 默认是1年，这里修改成10年 &quot;usages&quot;: [ &quot;signing&quot;, &quot;key encipherment&quot;, &quot;server auth&quot; ] &#125;, &quot;client&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot;, # 默认是1年，这里修改成10年 &quot;usages&quot;: [ &quot;signing&quot;, &quot;key encipherment&quot;, &quot;client auth&quot; ] &#125; &#125; &#125;&#125;# 生成ca证书信息文件# cfssl print-defaults csr &gt; ca-csr.json# cat ca-csr.json &#123; &quot;CN&quot;: &quot;example.net&quot;, # 标识具体的域 &quot;hosts&quot;: [ # 使用该证书的域名 &quot;example.net&quot;, &quot;www.example.net&quot; ], &quot;key&quot;: &#123; # 加密方式，一般使用rsa，大小使用2048 &quot;algo&quot;: &quot;ecdsa&quot;, # 加密方式，默认是ecdsa，此处使用rsa &quot;size&quot;: 256 # 默认是256，此处使用2048 &#125;, &quot;names&quot;: [ # 证书中包含的国家地区和城市信息 &#123; &quot;C&quot;: &quot;US&quot;, # 表示国家，修改成CN &quot;L&quot;: &quot;CA&quot;, # 区域，这里修改成SiChuan &quot;ST&quot;: &quot;San Francisco&quot; # 城市，修改成本地国内城市，ChengDu &#125; ]&#125;# 使用证书信息文件生成证书# cfssl gencert -initca ca-csr.json | cfssljson -bare ca -2021/04/05 13:07:11 [INFO] generating a new CA key and certificate from CSR2021/04/05 13:07:11 [INFO] generate received request2021/04/05 13:07:11 [INFO] received CSR2021/04/05 13:07:11 [INFO] generating key: rsa-20482021/04/05 13:07:12 [INFO] encoded CSR2021/04/05 13:07:12 [INFO] signed certificate with serial number 697269161568410809548825101035635405041110584154# 执行完成后，将生成两个pem文件，如下# ls *.pemca-key.pem ca.pem# 签署服务端证书# cp ca-csr.json reg.com-csr.json # vim reg.com-csr.json&#123; &quot;CN&quot;: &quot;reg.com&quot;, # 跟harbor配置文件中的域名一致 &quot;hosts&quot;: [], &quot;key&quot;: &#123; # 加密方式 &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 &#125;, &quot;names&quot;: [ # 证书中包含的国家地区和城市信息 &#123; &quot;C&quot;: &quot;CN&quot;, # 国家 &quot;L&quot;: &quot;SiChuan&quot;, # 区域 &quot;ST&quot;: &quot;ChengDu&quot; # 城市 &#125; ]&#125;# 签发证书# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www reg.com-csr.json | cfssljson -bare reg.com2021/04/05 13:07:56 [INFO] generate received request2021/04/05 13:07:56 [INFO] received CSR2021/04/05 13:07:56 [INFO] generating key: rsa-20482021/04/05 13:07:56 [INFO] encoded CSR2021/04/05 13:07:56 [INFO] signed certificate with serial number 1847975518655981104997457290808260420647146566582021/04/05 13:07:56 [WARNING] This certificate lacks a &quot;hosts&quot; field. This makes it unsuitable forwebsites. For more information see the Baseline Requirements for the Issuance and Managementof Publicly-Trusted Certificates, v.1.1.6, from the CA/Browser Forum (https://cabforum.org);specifically, section 10.2.3 (&quot;Information Requirements&quot;).# ls *.pemca-key.pem ca.pem reg.com-key.pem reg.com.pem 修改harbor配置文件，将证书路径写入harbor配置文件中 123456789101112# ls /etc/docker/sslreg.com-key.pem reg.com.pem# vim harbor.yml.tmpl # 将路径写入即可···http port: 80 # 注释掉关于http的信息https: port: 443 certificate: /etc/docker/ssl/reg.com.pem private_key: /etc/docker/ssl/reg.com-key.pem··· 2.2.3.4 安装123456789101112131415161718192021# 准备配置文件# cd /root/harbor &amp;&amp; mv harbor.yml.tmpl harbor.yml # docker image load -i harbor.v2.2.1.tar.gz &amp;&amp; ./prepare # 安装并启动harbor容器# ./install.sh····Creating network &quot;harbor_harbor&quot; with the default driverCreating harbor-log ... doneCreating harbor-db ... doneCreating registry ... doneCreating harbor-portal ... doneCreating redis ... doneCreating registryctl ... doneCreating harbor-core ... doneCreating nginx ... doneCreating harbor-jobservice ... done✔ ----Harbor has been installed and started successfully.---- ## docker contianer ls 2.3 访问web页面​ 将reg.com域名解析写入windows主机中的hosts文件，做完域名解析后在web浏览器中输入域名，由于我们使用的是自签证书，因此还是会提示链接不安全(并显示在浏览器uri前面)，点击”添加另外”即可： 登陆界面如下，用户名admin，密码为harbor.yml文件中定义的admin密码： 进入控制台，不喜欢该主题的话，可以点击下方浅色主题进行切换 查看证书信息 证书信息： ​ docker仓库搭建就完成，docker仓库的使用方法，请参考下一个章节的文章。 第二章 harbor仓库的使用1.命令行登陆到harbor仓库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 从另外的主机访问harbor仓库# docker login https://reg.comUsername: adminPassword: Error response from daemon: login attempt to https://reg.com/v2/ failed with status: 404 Not Found# 提示找不到https://reg.com，解决方法做hosts域名解析# echo &quot;10.138.3.111 reg.com&quot; &gt;&gt; /etc/hosts# 做完hosts域名解析后，再一次登陆，提示未知的认证# docker login https://reg.comUsername: adminPassword: Error response from daemon: Get https://reg.com/v2/: x509: certificate signed by unknown authority# 此时查看harbor主机上的messages日志，将看到访问失败的信息Apr 5 15:20:13 reg dockerd: time=&quot;2021-04-05T15:20:13.964537621+08:00&quot; level=error msg=&quot;Handler for POST /v1.41/auth returned error: login attempt to https://reg.com/v2/ failed with status: 404 Not Found&quot;Apr 5 15:24:35 reg dockerd: time=&quot;2021-04-05T15:24:35.416729925+08:00&quot; level=info msg=&quot;Error logging in to endpoint, trying next endpoint&quot; error=&quot;Get https://reg.com/v2/: x509: certificate signed by unknown authority&quot;# 解决方法，将harbor主机上的自签证书拷贝到需要访问harbor的主机上mkdir /etc/docker/certs.d/reg.com -p # 在被访问主机上新建目录，目录名称是/etc/docker/certs.d/harbor主机域名# 将harbor主机上的reg.com.pem文件拷贝到被访问主机上，名称后缀为.crt，不是.pem# scp -P 10022 /etc/docker/ssl/reg.com.pem 10.138.3.111:/etc/docker/certs.d/reg.com/reg.com.crt# 再次访问就没有问题了# docker login https://reg.comUsername: adminPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded# 查看主机上所有镜像# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEphp lnmp_php_7.4.16 960a00c2710a 6 hours ago 712MBnginx lnmp_ningx_1.18.0 438f02d48ea9 15 hours ago 489MBmysql 5.7 cd0f0b1e283d 5 days ago 449MBcentos centos7.6.1810 f1cb7c7d58b7 2 years ago 202MB# 给centos镜像修改标签# docker tag centos:centos7.6.1810 reg.com/library/centos:centos7.6.1810# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEphp lnmp_php_7.4.16 960a00c2710a 6 hours ago 712MBnginx lnmp_ningx_1.18.0 438f02d48ea9 15 hours ago 489MBmysql 5.7 cd0f0b1e283d 5 days ago 449MBcentos centos7.6.1810 f1cb7c7d58b7 2 years ago 202MBreg.com/library/centos centos7.6.1810 f1cb7c7d58b7 2 years ago 202MB# 推送centos镜像到reg.com仓库中# docker push reg.com/library/centos:centos7.6.1810The push refers to repository [reg.com/library/centos]89169d87dbe2: Pushed centos7.6.1810: digest: sha256:747b2de199b6197a26eb1a24d69740d25483995842b2d2f75824095e9d1d19eb size: 529 2.推送镜像到harbor仓库​ harbor仓库中给出的镜像推送方法提示： 镜像推送完成后，我们刷新页面，查看harbor页面上的镜像信息： 3. harbor集群 通过前文的方法，配置多台harbor主机，此处使用http协议进行访问，具体方法不再赘述。 安装完成后，登陆备库 登陆主库进行主备配置，点击仓库管理–&gt;新建目标，填入备库的访问地址，输入备库的访问用户和密码，如图所示： 测试连接： 1234567# 进入harbor安装目录，执行命令，停止harbor镜像仓库# docker-compose down # vim /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;: [&quot;10.138.3.222:80&quot;] # 将被控端域名添加信任&#125; 完成后，如下： 新建复制规则： 创建完成后，如下： 现在，我们推送一个镜像到reg.com主库中，查看备库10.138.3.222:80是否进行了同步 12345678910111213141516# docker tag mysql:5.7 reg.com/library/mysql:5.7# docker image ls | grep mysql mysql 5.7 cd0f0b1e283d 6 days ago 449MBreg.com/library/mysql 5.7 cd0f0b1e283d 6 days ago 449MB# docker login reg.com # 登陆主库Authenticating with existing credentials...WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded# 推送镜像到主库# docker push reg.com/library/mysql:5.7 查看reg.com主库，检查是否推送成功 查看reg.com上复制管理中的信息，显示复制成功 检查备库10.138.3.222:80是否成功同步了msyql:5.7 同步成功 配置主主 12345678# mkdir /etc/docker/certs.d/reg.com -p # 在备服务器上新建目录# 将reg.com主机上的认证文件拷贝到备服务器上# scp -P 10022 /etc/docker/ssl/reg.com.pem 10.138.3.222:/etc/docker/certs.d/reg.com/reg.com.crt# 查看备服务器上的认证文件# ls /etc/docker/certs.d/reg.com/reg.com.crt /etc/docker/certs.d/reg.com/reg.com.crt 主从复制+备份harbor数据目录/data/+数据库文件 12345678910111213141516171819202122# 日志文件# ls /var/log/harbor/core.log jobservice.log portal.log postgresql.log proxy.log redis.log registryctl.log registry.log# harbor数据文件ls /data/ca_download database job_logs redis registry secretls /data/registry/docker/registry/v2/repositories/library/centos/_layers _manifests _uploads # library/centos是我们刚刚上传的centos镜像# ls /data/secret/cert core keys registry# ls /data/secret/core/private_key.pem# ls /data/secret/cert/server.crt server.key# ls /data/secret/keys/secretkey# ls /data/secret/registry/root.crt 附：忘记harbor登陆密码的解决方法123456789101112131415161718192021222324252627282930313233# echo -n &quot;Admin@2020&quot;|md5sum06d1108043ad13aebdca098c7e6bfe64 -[root@reg ~]# docker exec -it harbor-db /bin/bash # 进入数据库容器 postgres [ / ]$ netstat -lntp Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 0.0.0.0:5432 0.0.0.0:* LISTEN 1/postgres tcp 0 0 127.0.0.11:34651 0.0.0.0:* LISTEN - tcp6 0 0 :::5432 :::* LISTEN 1/postgres postgres [ / ]$ psql -U postgres -d postgres -h 127.0.0.1 -p 5432 # 登陆数据库psql (9.6.21)Type &quot;help&quot; for help.postgres=# helpYou are using psql, the command-line interface to PostgreSQL.Type: \\copyright for distribution terms \\h for help with SQL commands \\? for help with psql commands \\g or terminate with semicolon to execute query \\q to quitpostgres=# \\c registry # 切换到registry数据库中You are now connected to database &quot;registry&quot; as user &quot;postgres&quot;.registry=# select * from harbor_user; user_id | username | password |realname | salt |---------+-----------+---------------------------------+---------------+-----------------------------+ 2 | anonymous | | anonymous user| | 1 | admin |b5361d73851310e3f99e417c21f00fff | system admin |F9xavf065XBc44obZewfrSrVkUoF42Gd (2 rows) 第三章 prometheus+grafana监控docker主机监控系统概述： cAdvisor(container cAdvisor)：用于收集正在运行的容器资源使用和性能信息，在每个docker 主机上部署 https://github.com/google/cAdvisor Prometheus：容器监控系统，从cAdvisor收集并存储数据，官网https://prometheus.io/ Grafana：开源可视化展示系统，官网https://grafana.com/grafana 1.配置cAdvisor1.1 安装cAdvisor​ 可通过GitHub中cAdvisor的运行容器命令，运行cAdvisor 1234567891011121314151617181920212223242526272829303132docker run \\ --volume=/:/rootfs:ro \\ --volume=/var/run:/var/run:ro \\ --volume=/sys:/sys:ro \\ --volume=/var/lib/docker/:/var/lib/docker:ro \\ --volume=/dev/disk/:/dev/disk:ro \\ --publish=8080:8080 \\ --detach=true \\ --name=cadvisor \\ --privileged \\ --device=/dev/kmsg \\ google/cadvisor:latest # Github中的源地址可能访问不了，因此这里更换成dockerhub中的地址Unable to find image &#x27;google/cadvisor:latest&#x27; locallylatest: Pulling from google/cadvisorff3a5c916c92: Downloading 44a45bb65cdf: Download complete 0bbe1a2fe2a6: Download complete latest: Pulling from google/cadvisorff3a5c916c92: Pull complete 44a45bb65cdf: Pull complete 0bbe1a2fe2a6: Pull complete Digest: sha256:815386ebbe9a3490f38785ab11bda34ec8dacf4634af77b8912832d4f85dca04Status: Downloaded newer image for google/cadvisor:latestWARNING: IPv4 forwarding is disabled. Networking will not work. # 此处有一个报错，需要打开路由转发功能e1132c19a4129804a28c1c0d0d61884ced3d548625daf882834095a420d3da7a# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES886e2bce936f google/cadvisor:latest &quot;/usr/bin/cadvisor -…&quot; 12 seconds ago Up 11 seconds 0.0.0.0:8080-&gt;8080/tcp cadvisor60d4d688b698 php:lnmp_php_7.4.16 &quot;./sbin/php-fpm -c /…&quot; 6 hours ago Restarting (78) 3 seconds ago lnmp_php10124a1d6b8b mysql:5.7 &quot;docker-entrypoint.s…&quot; 16 hours ago Up 7 hours 33060/tcp, 0.0.0.0:13306-&gt;3306/tcp lnmp_mysql 1.2 访问 cAdvisor​ 直接在浏览器中输入url–http://10.138.3.130:8080访问cAdvisor，访问较慢 第一次实验的时候一直不能通过http://10.138.3.130:8080/访问，重新删除并安装cAdvisor容器，发现执行完新建cAdvisor容器后有一个报错信息`WARNING: IPv4 forwarding is disabled. Networking will not work.，解决方法是打开路由转发功能echo ‘net.ipv4.ip_forward=1’ &gt;&gt; /usr/lib/sysctl.d/00-system.conf` 查看宿主机上运行的容器信息： 2. 配置prometheus2.1 安装prometheus​ prometheus可部署在任意的宿主机上， cAdvisor暴露出来的指标必须要符合prometheus的格式，才能被prometheus采集，我们在浏览器中输入http://10.138.3.130:8080/metrics，即可查看到符合prometheus格式的信息 12345# 安装prometheus# docker run -d --name prometheus -p 9090:9090 prom/prometheus# docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfe3468745563 prom/prometheus &quot;/bin/prometheus --c…&quot; 6 seconds ago Up 5 seconds 0.0.0.0:9090-&gt;9090/tcp prometheus 2.2 访问prometheus​ 在浏览器中访问http://ip:9090/config，如下： 2.3 添加监控主机​ 修改prometheus配置文件，让prometheus采集数据，每一个被监控端的信息都需要写入prometheus的配置文件，prometheus才能采集到数据，更改配置文件就是让prometheus知道去哪里取数据。 12345678910111213141516171819# 进入prometheus容器中# docker exec -it fe3468745563 sh /prometheus $ vi /etc/prometheus/prometheus.yml scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config. - job_name: &#x27;prometheus&#x27; # 等同于分组的组名 static_configs: - targets: [&#x27;localhost:9090&#x27;] # 被监控的目标端 - job_name: &#x27;docker&#x27; # 新建一个docker分组 static_configs: - targets: [&#x27;10.138.3.130:8080&#x27;] # 添加cAdvisor的接口，就能监控到数据；多个被监控端，用逗号隔开# 重启生效# docker container restart fe3468745563 # docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfe3468745563 prom/prometheus &quot;/bin/prometheus --c…&quot; 17 minutes ago Up 14 seconds 0.0.0.0:9090-&gt;9090/tcp prometheus ​ 此时就能在prometheus的targets页面查看新添加的主机信息： ​ 现在我们可以通过在prometheus的Graph页面输入promql查看指定的性能数据了 ​ 如下，这里只要输入一个字符，就能列出跟含有该字符的所有的promql，非常方便 3.配置Grafana3.1 安装Grafana1234# docker run -d --name grafana -p 3000:3000 grafana/grafana# docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES99ec838588e1 grafana/grafana &quot;/run.sh&quot; 39 seconds ago Up 37 seconds 0.0.0.0:3000-&gt;3000/tcp grafana 3.2 登陆Grafana​ 登陆grafana，用户和密码都是admin，登陆后会要求修改密码。 ​ 修改密码后(Admin)，进入主页： 3.3 配置Grafana3.3.1 添加数据源–Prometheus​ 首先，添加一个数据源–即告诉Grafana去哪里获取数据，点击DATA SOURCES，使grafana连接到prometheus，下图页面展示了所有能添加的数据源。 ​ 输入Prometheus的访问地址，并保存。 ​ 查看添加的数据源信息： 3.3.2 添加自定义仪表盘 ​ 默认的仪表盘页面(更正：下文中截图Prometheus的查询语句promql，误写成了proql)如下： ​ 此时我们即将使用到promql，即将promql添加到Grafana仪表盘中的Metrics中Grafana将在该图形中展示哪种promethues中的数据，我们依旧可以通过prometheus界面上的Graph进行调试，如监控内存，我们列出所有跟容器相关的container_memory_usage_bytes的信息 ​ 下面，我们通过筛选条件，列出容器的container_memory_usage_bytes信息，promql语句为container_memory_usage_bytes&#123;image!=&quot;&quot;&#125; ​ 接下来，我们采集具体的容器，如名称为cAdvisor的容器的信息，promql为container_memory_usage_bytes&#123;image!=&quot;&quot;,name=&quot;cadvisor&quot;&#125;，如下 ​ 将上面得到的promql写入到grafana中的metrics，就能得到数据 ​ 完成后，如下图所示： 3.3.3 添加模板仪表盘​ 如果每台机器都要这样手动配置一个图形的话，对于十来台服务器来说还可以接受，但对于成有千上万台的服务器的公司来说，这样的配置方式无疑是灾难性的，因此有没有一个通用的模板呢？答案是肯定的，grafana官网提供了很多这样的监控模板，访问地址–https://grafana.com/grafana/dashboards/： ​ 监控docker主机模板ID：193，即使用url–https://grafana.com/grafana/dashboards/193 在grafana首页中，点击manage–&gt;import，输入193导入模板 输入193点击load按钮 点击load后，自动加载 导入后，即可看到仪表盘数据内容 ​ 这里的仪表盘只是大佬给我们做好了的模板，本质上也是通过promql自定义仪表盘来做的，例如，我们查看上图中的Total Memory Usage，点击Edit来到编辑界面 ​ promql语句如下： 一些常见的坑： 不展示数据： 可能是宿主机由于时间不同步 promql格式有问题，可以通过prometheus的Graph进行检查 prometheus本来就没有数据 cAdvisor+prometheus+grafana进行监控的步骤总结： 在被监控主机上安装cAdvisor容器，让cAdvisor收集宿主机数据 将宿主机监控端写入prometheus配置文件，让Prometheus能够获得cAdvisor采集到宿主机的监控数据 添加到grafana仪表盘(但是每天主机都添加一个仪表盘是不是很烦呢？能否一个界面显示所有的主机呢？需要查看哪台主机就点击哪台主机呢？) ​ 点击下图中的设置按钮，进入设置选项 ​ 点击Versions，添加变量 ​ 如下，列出所有分组(或主机)信息，即dashboard中是按照job还是instance显示主机： ​ 上图中的配置，我们仍然是通过promql实现，在Graph页面显示不出的数据，不可能在grafana中能显示图形。 ​ 此时，查看grafana仪表盘，就多了选择框，可以选择主机或分组，上图中add variables(添加变量)时使用 的是instance就显示所有主机的信息，添加的是job就会显示所有分组的信息。 ​ 但是，现在我们选择两个不同的节点，图表的结果是一样的，因为promql中的语句写死了，没有采集到对应node节点主机的信息，因此需要修改，方法如下，先点击进入其中一个仪表盘的修改界面： ​ 添加上每台主机，在原promql的基础上，添加上&quot;instance=&#39;$Node&#39;&quot;，变量Node是我们上文中通过add variables自定义的变量名称 ​ 通过这样的修改，得到的就是每一台主机的内存使用量了，然后再将该仪表盘中的其他仪表盘promql都进行这样的修改，就能展示出每台主机独特的信息。","categories":[{"name":"docker","slug":"docker","permalink":"https://scaven.site/categories/docker/"}],"tags":[{"name":"kubernets","slug":"kubernets","permalink":"https://scaven.site/tags/kubernets/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://scaven.site/categories/python/"},{"name":"docker","slug":"docker","permalink":"https://scaven.site/categories/docker/"},{"name":"Home","slug":"Home","permalink":"https://scaven.site/categories/Home/"}],"tags":[{"name":"python","slug":"python","permalink":"https://scaven.site/tags/python/"},{"name":"kubernets","slug":"kubernets","permalink":"https://scaven.site/tags/kubernets/"},{"name":"AboutMe","slug":"AboutMe","permalink":"https://scaven.site/tags/AboutMe/"},{"name":"welcome","slug":"welcome","permalink":"https://scaven.site/tags/welcome/"}]}